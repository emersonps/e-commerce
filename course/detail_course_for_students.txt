1- HTML

1. Baixar o xampp e configurar os arquivos: hosts, httpd-vhosts.conf
2. Testar um arquivo com texto puro e explanar a questão de interpretação do navegador à textos com e sem acento.
3. Denotar textos marcação que formatem o texto, assim mostrando marcadores que influenciam a maneira com que cada texto será exibido (html, head, title, meta charset=utf-8, body, h1, h2, ul, li).
4. Esplanar sobre o uso dessas marcaçoes mostrando o termo usado definitivamente durante o curso: tags.
5. Mostrar aos alunos que a ineficiência de estética das marcações html (tags) é onde encontra-se o seu primeiro desafio como programador frontend.
6. Esplanar um pequeno resumo da origem do HTML e a necessidade de usá-la nos dias atuais para desenvolvimento web.
7. Esplanar o conceito usual de cada tag e do conjunto de tags que forma o HTML, sintaxe e:
8. Denotar o uso de cada tag usada no primeiro exemplo.
9. Mostrar aos alunos tags que podem receber atributos, e nem todas possuem uma tag de fechamento, exemplificando com o uso da tag <img src="c:\site\index.html"> por não ter conteúdo por si só.
10. Notar as tags de estrutura do HTML: <html>, <head>, <body>, e a instrução <!DOCTYPE>, esclarecendo a declaração hierarquica das tags pais e filhos.
11. Declaração da instrução especial <!DOCTYPE html>, que não se trata de uma tag. Apresentar a sua função e mostrar aos alunos que existiam comando antigos e complexo, mas que hoje faz-se uso apenas dessa declaração simples.
12. Explanar aos alunos que o HTML5 possui diversas tags novas e apresentar as tags de: títulos, parágrafos e ênfase:
<h1> ~ <h6> - heading - segundo as ordens de importância. 
13. Explanar uma breve explicação sobre a importância dessas tags heading, levando em consideração a ordem e relevância de seu uso nos sites de pesquisas como google, yahoo, etc..., e o uso das mesmas em navegadores especiais para acessibilidad e facilidade de usuários, diferenciando seus conteúdos.
14. Exemplificar uso de Tags de para parágrafos <p>
15. Apresentar tags de ênfase: <strong>, <em>, <b>, <i>, <small>
16. Explanar o uso da tag <img> e seus atributos: src, alt.
17. Exemplificar usos das tags adjacentes da tag <img>, tais como: <figure>: usada igual a tag <img>, mas permitindo usar a tag auxiliar: <figcaption>, onde acopla-se uma legenda à imagem.
18. Explicar sobre a estrutura e que não há nenhum rigor técnico que defina o uso de uma melhor organização do projeto, mas geralmente adaptaremos de maneira que fique melhor para o nosso entendimento.
19. Prepara a estrutura de diretórios para organizar o projeto em: css, img e js
20. Breve conceito de IDES (IntegratedDevelopment Environment). IDEs com realce de sintaxe: gedit, sublime, atom, notepad++; E os IDEs com  autocompletar e visualização como o Exlipse e o Visual Studio.

Exercício de HTML

2 - CSS

1. Após o exercício, declarar alguns exemplos de Estilização no próprio HTML para que os alunos possam entender com mais clareza como eram estilizados os textos no passado, mostrando a eles que no lugar dessa metodologia surgiu o CSS.
2. Em seguida entrar no conceito de que o efeito da folha de estilo é agregado ao HTML por arquivos separados ou no próprio código HTML.
3. Sintaxe (atributos e valores) e Inclusão de CSS: {color: blue; background: yellow} 
4. Exemplificar com as duas maneiras (no próprio código e com css e com a tag style).
5. Exemplificar o uso de CSS com arquivo externo (<link	rel="stylesheet" href="estilos.css">) com a chamada dentro do HEAD
6. Conceito tipográficos - criar exemplo de formatação para paragrafos, títulos:
 - Usar como exemplo de família de fontes: fontes serifadas (serif: Times New Roman), fontes sem serifas (sans-serif: Arial, Arial Black), e fontes monospace (Fontes com curvas mais delicadas: Courier)
 - Usar um tipo de fonte padrão para todo o documento HTML, acplicando um estilo de fonte no body{font-family: "Arial",	"Helvetica", sans-serif;}
7. Exemplificar o uso de estilos de fonte com a propriedade font-style: (normal, italic, oblique)
8. Trabalhar com o conceito de alinhamento e decoração de texto, exemplificando com os seguintes atributos e valores:
 - text-align: right / center / left / jutify;
 - Definir uma série de espaçamento de texto, como a seguir:
p{
 line-height: 3px;	/*	tamanho	da	altura	de	cada	linha	*/
 letter-spacing: 3px;	/*	tamanho	do	espaço	entre	cada	letra	*/
 word-spacing: 5px;	/*	tamanho	do	espaço	entre	cada	palavra	*/
 text-indent: 30px;	/*	tamanho	da	margem	da	primeira	linha	do	texto	*/
}
9. Fazer uso de imagens de fundo, com exemplos claros de uso da sintaxe:
h1{
 background-image: url(sobre-background.jpg);
}

10. Uso de bordas, exemplificando aplicação na página, mostrando as duas sintaxes do atributo, incluíndo o uso do border-style: none, e também fazer testes como os valores do atributo style: dashed, dotted, double, groove;
Exemplo:
body{
 border-color:	red;
 border-style:	solid;
 border-width: 1px;
}

ou 

body{
 border: 1px	solid	red;
}

Exercício de CSS

CSS - Parte 2

1. Definição de uso RGB, mostrar aos alunos o conceito de formação de cores RGB - forma mais 16 milhões de cores com a combinação de três cores bases: Red, Green e Blue, variando a intensidade de cada uma de suas cores entre 0 e 255. - Fazer uso de uma aplicação que facilite a descoberta ou formação das cores.
2. Exemplificar diversos usos de cores com os atributos color, background e border-color: yellow; rgb(255, 200, 0); 
- Mostrar que esses modos não é o mais comum por questão de incompatibilidade de navegadores;
- Fazer uso da notação hexadecimal: #F2EDED (suporte universal aos navegadores) 
- Mostrar aos alunos os dois canais que representam cada cor (RGB) nessa notação;
- Aplicar a teoria da formação de base hexadecimal (0 à 15 - decimal, sendo valores hexadecimal 0-9 e A-F);
- Exemplificar a simplificação de caracteres repetidos em hexadecimal. Exemplo: #EEFF66. Ficaria: #EF6;

Outros assuntos HTML e CSS para praticar:
1. Listas: 
	- Não ordenada: <ul><li>Item</li></ul>
	- Ordenada: <ol><li>Item</li></ol>
	- Lista de definição: <dl><dt>Titulo</dt><dd>paragrafo</dd><dt>Titulo 2</dt><dd>Parágrafo 2</dd></dl>
2. Espaçamento, Margens e Dimensões:
	- padding: para espaçamento interno; 
		- Subpropriedades: padding-top
				   padding-right
				   padding-bottom
                                   padding-left
		- shorthand property: mostrar o sentido horário em que se faz a leitura para a definição das 		subpropriedades
Exemplificar como:
p{
 padding: 10px; //valor aplicado a todas as direções
}

p{
 padding: 10px 15px; //padding-top e padding-bottom
}

p{
 padding: 10px 20px 15px; //padding-top, padding-right e padding-left, padding-bottom
}

p{
 padding: 10px 20px 15px 5px; //padding-top, padding-right, padding-bottom, padding-left
}

	- margin: para margens; - mostrar uso das propriedade e 'shorthand property' da mesma forma como do padding, e exemplificar que a diferença está em um limite de espaços além do elemento, ou seja, fora de seus limites, externamente.
p{
 margin: 0 auto; //margin-top e margin-bottom = 0; margin-right e margin-left = auto;
}

	- height e width: para dimensões - Exemplificar conforme o código abaixo:
p{
 background-color: red;
 height: 300px;
 width: 300px;
}

3. Links HTML - Exemplificar com exercícios propostos links (âncoras) redirecionando para outro endereço e ID (indentificadores): Visite o site da <a href="http://www.caelum.com.br">Caelum</a> e <p>Mais	informações <a href="#info">aqui</a>.</p> 

Exercícios de LINK

CSS Parte 3

1. Aplicar o conceito com exemplos e exercícios de ID e Filho (conceituando o uso de tags coringa como <div> e <span>):
- Seletor (no CSS) de ID: (#) => #cabecalho{color: white; text-align: center}, e indicar esse seletor a qualquer tag: p, div, span, desde que estejam identificadas: <span id="cabecalho"></span>
- Explanar aos alunos que o ID deve ser único em todo o documento (página), e em cascata, seus filhos.
2. Seletor Hierárquico: exemplificar com seletor (no css) e um elemento filho estilizado: 
#rodape img{
  margin-right: 30px;
  vertical-align: middle;
  width: 94px;
}
3. Float - Conceituar o uso do "float" que permite: tirar um elemento do fluxo vertical, ou elementos que ocupem toda a largura da página e fazer com que os elementos abaixo dele fula ao seu redor:

Exercícios: Seletores e Flutuação de Elementos
4. Deve-se explicar à turma o que muda no uso das tags no HTML5 e CSS3, sobre a semântica que devemos usar e sobre a compatibilidade com os navegadores.

 
HTML SEMÂNTICO E POSICIONAMENTO NO CSS

1. Conceituar o Processo de Desenvolvimento de uma tela falando sobre os levantamentos de requisitos, profissionais e ferramentas utilizadas para desenvolver um rascunho do projeto. (Recusros: Pesquisas, levantamento de requisitos com o cliente, profissionais: (Pessoas formadas na área de comunicação) e áreas responsáveis: UX (User Experience Design) e IxD (Interection Design).
2. Esboços das visões: chamados de wireframes e auxiliam no restante do design. (mostrar um exemplo de wireframe). - Mostrar aos alunos um exemplo de wireframe.
3. Com o wireframe em mãos: adicionar cores, imagens, textos. Trabalho de responsabilidade dos Designers, que usam como ferramanta: Photoshop, Fireworks, GIMP, etc.
4. Mostrar aos alunos que é à partir daí que a equipe de programadores frontend entra. Para dar vida ao projeto e fazer funcionar.
5. O Projeto Mirror Fashion - uma equipe de UX já desenvolveu a ideia que iremos praticar - Mostrar um modelo de como ficará a página.

ANALISANDO O LAYOUT
1. Levar os alunos a fazer uma análise do comportamento e disposição dos elementos na página, como por exemplo, o cabeçalho e rodapé que deverão ser padrão para as demais páginas e ensinar que a leitura dos elementos devem ser da esquerda para a direita e para baixo.

ESTRUTURA DA PÁGINA
1. Analisar que a página poderá ser dividida em três partes, sendo Cabeçalho, Conteúdo (será diferente para cada página), e rodapé.
2. Analisar a largura e limite de cada conteúdo dentro de cada um desses elementos

EXERCÍCIO INDEX
1. Adicionar os códigos de definição das áreas: 
<body>
  <header>
	<!-- Conteúdo do cabeçalho	-->
  </header>

  <div id="main">
  	<!-- Conteúdo principal	-->
  </div>

  <div id="destaques">
  	<!-- Painéis com destaques	-->
  </div>
  
  <footer>
	<!-- Conteúdo do rodapé	-->
	Estrutura da página.	
  </footer>
</body>

3. Explicar aos alunos o uso das novas tags que são parte do HTML 5 (<header> e <footer>)
4. Deixar claro o distinto papel de HTML e CSS, onde o papel do HTML é marcar o conteúdo da página, e que ele precisa ser claro e limpo; O Papel do CSS sim, é de estilizar, embelezar, dar cores e efeitos visuais à página.
5. Parte Semântica do HTML. Mostrar a importância disso na página para os usuários com deficiência visual, onde a leitura semântica HTML permite que o usuário com deficiência visual ouça a leitura da página.

ANALISANDO O HEADER
1. Verificar e analisar o conteúdo de dentro do HEADER: ícone, lista, mensagens, etc.
2. Questionar: que tipo de conteúdo usaremos? E a imagem com ícone? é um texto, ou um CSS decorativo?
3. Criar o primeiro conteúdo do Header:
	<header>
            <!--	Conteúdo	do	cabeçalho	-->
            <nav>
                <ul>
                    <li><a href="#">Sua Conta</a></li>
                    <li><a href="#">Lista de Desejos</a></li>
                    <li><a href="#">Cartão Fidelidade</a></li>
                    <li><a href="sobre.html">Sobre</a></li>
                    <li><a href="#">Ajuda</a></li>
                </ul>
            </nav>
        </header>
4. Conceituar ID e Class, onde ID deve ser único e Class pode ser usado mais de uma em um mesmo elemento.
5. Exercício do conteúdo: criando o header

CSS RESET
1. Mostrar aos alunos a importância do CSS Reset que evita que o navegador utilize uma série de estilos padrão quando não há um estilo definido pelo programador, forçando um estilo padrão que é setado sempre que carregarmos a página;
2. Fazer uso dos três arquivos: Reset (muda todos os valores possíveis para um valor padrão. Por exemplo: h1 e small têm o mesmo tamanho), Base (onde margens e dimensoes de alguns elementos são padronizados) e Font (define um tamanho para tipos de forma a tornar o visual consistente inclusive nos dispositivos móveis) - frontend do Yahoo;
3. CSS Resete do Eric Meyer - é um arquivo bem reduzido.


BLOCK VS INLINE
Falar sobre a distinção desses dois tipos de elementos:
1. Falar sobre os elementos em blocos, como <h1>, <p>, <div> etc, aqueles que ao serem inseridos podemos ver que não há um elemento à sua esquerda ou direita, pois ocupam toda a largura do documento.
2. Elementos em linha são aqueles que ocupam somente o espaço necessário para que seu próprio conteúdo seja exibido, permitindo a exibição dos próximos elementos na mesma linha, exemplo: <a>, <span>, <strong>, etc...
3. DISPLAY, o atributo que permite mudar o comportamento padrão desses dois tipos de elementos: display: block, display: inline.

Exercícios Reset e Display

POSITION: STATIC, RELATIVE E ABSOLUTE

1. Esplanar para os alunos os tipos de propriedades que permitem posicionar um elemento;
2. Explicar que os objetos não obedecem essas propriedade, pois dependem de outra propriedade: position;
3. Exemplificar que o position determina qual o modo de posicionamento de um elemento, na qual ele pode receber: POSITION: STATIC, RELATIVE E ABSOLUTE;

	Explicação para a turma:
- static => elemento com essa posição permanece com sua posição padrão, não obedecendo nenhum atributo de posicionamento;
- relative => permite atribuir obedecer as regras aplicadas de cordenadas especificadas em relação a posição original do objeto;
Exemplo:

.logotipo{
	position: relative;
	top: 20px;
	left: 50px;
}
- absolute => o mais complexo, pois exigem algumas regras que alteram seu comportamento em determinadas circustâncias. Por padrão, o elemento que recebe esse atributo usa como referência qualquer elemento que seja seu pai na estrutura HTML cujo o modo desse pai seja diferente de static (que é o padrão), e obedece as regras de coordenadas de acordo com o tamanho total desse elemento pai:
	Regra 1 - Quando o elemento não tem um pai, ele usa como referência para as suas coordenadas o limite da página do lado direito e superior (conforme indicado no atributo left, right, top ou bottom).
	Regra 2 - O mesmo acontece se definirmos a propriedade relative ao elemento pai, usando o elemento pai como base de referência para as suas coordenadas (superior e direita).
	Regra 3 - caso o elemento pai não tenha uma position definida ou static (padrão), o filho se comportará como na regra 1

EXERCÍCIO DE POSICIONAMENTO

SUPORTE HTML5 NO INTERNET EXPLORER ANTIGO

1. Mostrar aos alunos que somente há suporte para tags hmlt5 à partir do IE9.
2. Se abrirmos o site em navegadores antigos, veremos a página com o conteúdo quebrado, pois o navegador não possui suporte para as tags semânticas do html5: header, footer, nav, section, etc.
3. Entretanto, há um hack https://github.com/afarkas/html5shiv aprensentar aos alunos para que com isso possam usar as tags semânticas nos navegadores antigos:
colocar esse código dentro do HEAD:

<!--[if	lt	IE	9]>
	<script	src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

4. Em versões muitos antigas, onde 1% ainda usam essas versões de IE, versão 6 e 7, não funcionam normalmente as tags mesmo usando o hack.


MAIS HTML E CSS

1.Analisar as áres do corpo e rodapé da página.

FORMULÁRIOS

1. Explanar o uso da tag <form> que tem a função de capturar dados do usuário e submetê-los a algum serviço da Internet.
2. Filhos: <input> <button> e outros.
3. Exemplificar o fluxo de dados: passam para o <form> por meio da tag <input>, que recebe os dados digitados;
4. O atributo 'type' define a finalidade desse input. Exemplo: type="search";
5. Os dados são enviados para a tag <button> que submete as informações do formulário
<form>
	<input type="search">
	<button>Buscar</button>
</form>

POSICINAMENTO COM FLOAT E CLEAR

1. Exemplificar o clear como uma propriedade que pode ser definida com 'right', 'left', ou 'both' o comportamento dos elementos que estarão ao redor do objeto que será definido com essa propriedade. Podemos dizer que sua função é: "limpe o fluxo do documento ao meu lado", impedindo que os elementos fiquem à direita, à esquerda ou em ambos os lados, respectivamente.

Para usar Clear, o outro elemento deve estar com float especificado para qual posição irá flutuar, os elementos que preencherem o espaço do fluxo devem conter o clear e definir da seguinte forma:

left: Elemento é empurrado para baixo de elementos com float left;
right: Elemento é empurrado para baixo de elementos com float right;
both: Elemento é empurrado para baixo de elementos com float left ou float right;
none: Elemento não é empurrado para baixo de elementos com float.

TRANFORMAÇÃO DE TEXTO

1. Utilizar a propriedade text-transformation: uppercase, lowercase, capitalize, 
2. Decoração de texto: mostrar exemplos de texto decorados como: <a>, <del>

CASCATA E HERANÇA NO CSS
1. Explanar o uso de cascata e herança no CSS com exemplos de divs com class="pai", e filhos com tags h1 e h2
<div id="pai">
<h1>Sou um título</h1>
<h2>Sou um subtítulo</h2>
</div>
#pai {
	color: blue;
}

#pai {
	color: blue;
}

h1 {
	padding-left: 40px;
}

SELETORES DE ATRIBUTOS:
Exemplificar:

.busca input[type=search] {
	width: 170px;
}


INHERIT
valor atribuído a uma propriedade que queremos herdar nos filhos

Exemplificar aos alunos, uma imagem que preencha uma div conforma a definições de propriedades para essa div:

<div>
	<img src="box-model.png" alt="box model">
</div>

Sempre que definirmos o tamanho da div...
div {
	border: 2px solid;
	border-color: red;
	width: 30px;
	height: 30px;
}

Teríamos que definir o tamanho da imagem para caber na div...
img {
	width: 30px;
	height:	30px;
}

Ao atribuir Inherit nas mesmas propriedades do pai e do filho, teremos os valores do filho definido automaticamente igua ao do pai:
img {
	width: inherit;
	height: inherit;
}


EXERCÍCIO MENU DE DESTAQUE


DISPLAY INLINE-BLOCK
- Explicar aos alunos que ao fazermos alterações dimensionais em <li>s essas configurações de propriedades da box (width, height, margin) são ignoradas quando aplicamos o modo de exibição inline 
- os navegadores mais modernos permitem que usemos o momo inline-block na propriedade display, de modo que as especificações de dimensões são obedecida, e permite que os elementos sejam exibidos ao lado como lementos inline.

EXERCÍCIOS - PAINÉIS FLUTUANTES


SELETORES DE ATRIBUTOS DO CSS 4

1. À partir daqui deve-se apresentar conteúdo de CSS mais avançados, como o SELETOR DE ATRIBUTOS:
	- Valor de um atributo: input[value]{color:#CC0000} - o seletor altera todas as tags <input> que têm o atributo "value" 
	- Valor específico: input[type="text"]{border-radius: 4px} 
	- Selecionar valores condicionais, por exemplo, atributo com prefixo: div[class|="menu"]{border-radius: 4px;} - nesse caso, ele agirá em todas as tags <div> onde o atributo "div" comece com a palavra "menu" seguida de hífen e qualquer outro valor na sequência: menu-principa, menu-departamento, etc.
	- Valor por palavra específica = input[value~="problema"], que seja unicamente esse nome na classe.
 
2. Explanar o uso de expressões no CSS3 que se assemelham às expressões regulares que conhecemos.
Exemplificar:

input[name^="usuario"]{color: #CCFF00} => busca por input com valor de "name" iniciando em "usuario"

input[name$="teste"]{background-color: #CCFF00; => busca por input com valor de "name" terminandos em "teste"

input[name*="tela"]{color: #666666; => busca por input com valor do atributo "name" contendo "tela" em qualquer posição

- Mostrar que os valores de atributo tem a mesma especifidade dos seletores de classe.


RODAPÉ - SEMÂNTICA HTML 5

- Exemplificar o uso do <footer> na semântica do HTML 5
- Fazer uso do Image Replacement - substituição por imagem (serve para exibir uma imagem em algum elemento que originalmente foi feito com texto. 
	Ideia:
	- Acertar o tamanho do elemento para ficar igual ao da imagem;
	- Colocar a imagem como background do elemento;
	- Esconder o texto.

- Usar a técnica de esconder o texto cusando o 'text-ident' negativo alto, com isso fazer o texto ser renderizado "fora da tela".

ESTILIZAÇÃO E POSICIONAMENTO DO RODAPÉ

	Explicar que todo elemento que queremos manter uma largura padrão, teremos que usar a classe criada para isso: container

	1. CONTAINER INTEIRO
	2. POSICIONAMENTO

>>>>>>PREPARAR AULA ATÉ AQUI <<<<<<<<

SELETORES AVANÇADOS 

1. SELETOR DE IRMÃOS (SUBLINGS)
Utilizado para estilizar todo um parágrafo após um título.
h2 ~ p {
	font-style: italic;
}


2. SELETOR IRMÃO ADJACENTE
Utilizado para selecionar o elemento imediatamente seguinte ao título por exemplo, ou seja, o <p> irmao do <h2>

h2 + p {
	font-variant: small-caps;
}


3. SELETOR FILHO DIRETO
article > h1 {
	color: blue;
}


4. SELETOR NEGAÇÃO
Uma forma de selecionar um item em específico seria reestilizá-lo após uma aplicação de estilo padrão:
p {
	color: gray;
}
p.especial {
	color: black; /* restaura cor do especial */
}

ou com CSS3 usando a tag de estilo NEGAÇÃO:
p:not(.especial) {
	color: gray;
}

a sintaxe not recebe outros tipos de seletores, além de classes, como: ids e tags.

5. PSEUDO-CLASSES
5.1. FIRST-CHILD e LAST-CHILD
<ul>
<li>Primeiro item</li> (QUEREMOS ESSE PRIMEIRO ELEMENTO VERMELHO)
<li>Segundo item</li>
<li>Terceiro item</li>
<li>Quarto item</li> (QUEREMOS ESSE ÚLTIMO ELEMENTO AZUL)
</ul>

A solução mais comum seria:

criar uma classe para cada um dos dois elementos e aplicar a cor, mas isso requer mudança no HTML, e precisaremos mudar sempre a classe no local da alteração.

As duas classe utilizadas no CSS3 são: first-child (primeiro elemento do filho de outro) e last-child (último elemento filho):

li:first-child {
color: red;
}
li:last-child {
color: blue;
}


Obs.: O suporte a esses seletores é completo nos navegadores modernos. O first-child vem desde o IE7, Firefox 3 e Chrome 4. E (estranhamente), o last-child só a partir do IE9 mas desde o Firefox 1 e Chrome 1.

5.2. NTH-CHILD
Seletor ainda mais genérico:
	NTH-CHILD(ÍNDICE DO ELEMENTO FILHO){}

O mesmo permite usar uma expressão aritimética para valores pares ou ímpares:
/* elementos pares */
li:nth-child(2n) { color: green; }

/* elementos impares */
li:nth-child(2n+1) { color: blue; }

OBS.: O suporte existe a partir do IE9, Firefox 3.5 e Chrome 1.


PSEUDO-CLASSES DE ESTADO
Usamos para aplicar efeitos visuais que simulam ações de eventos do mouse sobre um objeto, invés de usarmos JS para esse tipo de efeito.

a:hover {
	background-color:#FF00FF;
}

/* seleciona todas as âncoras que têm o atributo "href", ou seja, links */
a:link {
background-color:#FF0000;
}
/* seleciona todos os links cujo valor de "href" é um endereço já visitado */
a:visited {
background-color:#00FF00;
}
/* seleciona o link no exato momento em que clicamos nele */
a:active {
background-color:#0000FF;
}

PSEUDO-ELEMENTOS
No exemplo abaixo queremos alterar o tamanho e estilo apenas da letra 'A'. Para isso, ingenuamente, utilizaríamos uma classe <span>a</span>. Isso custaria mais trabalho de manutenção no HTML.
<p>A Caelum tem os melhores cursos!</p>

Pseudo-elementos são elementos que não existem no documento mas que podemo ser selecionados pelo CSS:

p::first-letter {
	font-size: 200%;
}

p::first-line {
	font-style: italic;
}


Alterar somente a primeira linha dos parágrafo que não procede de outro parágrafo, mas sim procedidas por títulos, figuras e etc.

:not(p) + p::first-line {
    font-variant: small-caps;
}


NOVOS CONTEÚDOS
Imagine uma lista de links que desejamos utilizar colchetes antes e depois de cada link:

[ Link 1 ]
[ Link 2 ]
[ Link 3 ]

Podemos simplesmente digitar esses valores na tela, então perguntamos:
 - Será que esses valores serão semânticos? 
 - Queremos que os colchetes sejam indexados no Google?
 - Queremos que sejam lidos como parte de texto pelos leitores de tela

Talvez não, por ser apenas um conteúdo visual. Podemos gerar os pseudo-elementos 'after' e 'before'

a:before {
	content: '[ ';
}
a:after {
	content: ' ]';
}

Podemos também adicionar um conteúdo usando pseudo-elementos com seletores de atributos:
a[href^=http//]:after {
    content: ' (externo)';
}

BORDAS ARREDONDADAS

/* todas as bordas arredondadas com um raio de 15px */
.a {
	border-radius: 15px;
}

/* borda superior esquerda e inferior direita com 5px
borda superior direita e inferior esquerda com 20px */
.b {
	border-radius: 5px 20px;
}

/* borda superior esquerda com 5px
borda superior direita e inferior esquerda com 20px
borda inferior direita com 50px */
.c {
	border-radius: 5px 20px 50px;
}

/* borda superior esquerda com 5px
borda superior direita com 20px
borda inferior direita com 50px
borda inferior esquerda com 100px */
.d {
	border-radius: 5px 20px 50px 100px;
}


TEXT-SHADOW
1. Deslocamento da sombra e cor:
p {
	text-shadow: 10px 10px red;
}

2. Grau de Espelhamento: (blur)
p {
	text-shadow: 10px 10px 5px red;
}

3. Mais de uma sombra:
p {
	text-shadow: 10px 10px 5px red, -5px -5px 4px red;
}

BOX-SHADOW
Sintaxe identica a do Text-shadow:
	1. Sombra simples	
	box-shadow: 20px 20px black;
	
	2. Sombra com blur
	box-shadow: 20px 20px 20px black;

	3. Aumentar e diminuir sombra
	box-shadow: 20px 20px 20px 30px black;

	4. Borda interna no elemento (inset)
	box-shadow: inset 0 0 40px black;


OPACIDADE E EGBA

Desde o CSS2 podemos aplicar uma transparência em objetos usando a propriedade opacity usando valores que variam entre 0 e 1:
p {
	opacity: 0.3;
}

Compatíveis com todos o tipos de canais de cores:
/* todos equivalentes */
color: white;
color: #FFFFFF;
color: rgb(255, 255, 255);

no CSS3 o modo rgb vem com um canal a mais de cores, que é o chamado de alpha, que na prática é como a propriedade de transparência do elemento:

/* branco com 80% de opacidade */
color: rgba(255,255,255, 0.8);

No caso de texto queremos apenas o fundo dele transparente e não o texto junto:
p {
	background-color: rgba(0,0,0,0.3);
	color: white;
}


CONCEITOS:

PREFIXO:
Muitos recursos do CSS3 e HTML5 ainda são experimentais, ou pelo menos eram há alguns anos atrás. As especificações ainda estão em aberto o que indica que pode levar algum tempo para que sejam fechadas.

Alguns recursos são mais estáveis e outros mais instáveis. Alguns já estão há bastante tempo na espec e não são esperadas mudanças. Por fim, alguns ainda podem sofrer mudanças por serem bem recentes.

Alguns navegadores utilizam recursos que, na prática, facilita o uso desses novos recursos até que sejam concluídos e os navegadores implementem essas novas propriedades.

Enquanto isso, fazemos uso de um recurso chamado "prefixo" específico do fabricante na frente. Quando a especificação ficar instável, tira-se esse prefixo e usa apenas a propriedade (faz-se uso da sintaxe oficial):

Alguns prefixos de fabricantes mais famosos são:
-webkit-: navegadores Webkit (Chrome, Safari, iOS, Android)
-moz-: Firefox (Mozilla)
-ms-: Internet Explorer (Microsoft)
-o-: Opera

É preciso consultar tabelas de compatibilidade para saber qual navegador suporta qual propriedade e se é necessário usar prefixos para certas versões. Se quisermos o máximo de compatibilidade, precisamos colocar vários prefixos ao mesmo tempo:

p {
/* Chrome até versão 3, Safari até versão 4 */
-webkit-border-radius: 5px;
/* Firefox até versão 3.6 */
-moz-border-radius: 5px;
/* Todas as versões modernas dos navegadores,
incluindo IE e Opera que nunca precisaram de
prefixo pra isso */
border-radius: 5px;
}


No caso do CSS3, todas as propriedades usadas até o momento são suportadas nos navegadores mais modernos: border-radius, text-shadow, box-shadow, rgba, e podem ser usados sem uso do prefixo.


GRADIENTES
Podemos usar gradientes no CSS3 sem que precisemos fazer uso de imagens.
Vantagens:
	- Simples
	- Página mais leve
	- Se adapta a todo tipo de resolução

- Tipos: Lineares e Radiais

- Sintaxe: 

.linear {
	background: linear-gradient(white, blue);
}

.radial {
	background: radial-gradient(white, blue);
}


- Uso de gradiente com angulações diferentes e diversas paradas de cores:
.gradiente {
	background: linear-gradient(45deg, #F0F9FF 0%, #CBEBFF 47%, #A1DBFF 100%);
}


GERAÇÃO DE GRADIENTE
No exemplo abaixo os navegadores mais modernos irão ignorar a cor sólida de ler a regra gradiente:

.gradiente {
	background: #CBEBFF;
	background: linear-gradient(45deg, #F0F9FF 0%, #CBEBFF 47%, #A1DBFF 100%);
}

Podemos fazer uso de uma ferramente que permite gerar elementos gradientes em estilo visual:
https://www.colorzilla.com/gradient-editor/


PROGRESSIVE ENHANCEMENT E GRACEFUL DEGRADATION

A ideia é fazer o site funcionar em qualquer navegador sem prejudicar os navegadores mais antigos e sem deixar de usar os novos recursos nos navegadores mais modernos.

'Graceful Degratation' (degradação graciosa) - foi a primeira técnica que veio com essa ideia. O objetivo era montar o site voltado aos navegadores mais modernos e fazer com que ele degradasse "graciosamente", removendo funcionalidades não suportada.

'Progressive Enhancement - tem uma ideia parecida, mas contrária. Desenvolve funcionalidades normalmente, a acrescenta-se pequenas melhorias mesmo que só funcione nos navegadores modernos. 

o CSS3 usa esse último modo. Desenvolvemos com CSS3 e acrescentamos melhorias aos poucos.


TRANSITIONS

1. Propriedade que podemos usar para definição de estilos e efeitos:

#teste {
position: relative;
	top: 10px;
}

#teste:hover {
	top: 30px;
}

Mas veremos um efeito de deslocamento menos sutil. Podemos usar efeitos de transição:

#teste:hover {
	transition: top 2s;
}

2. Por padrão a animação é linear, mas podemos usar outros tipos:
	linear		-	velocidade constante na animação;
	ease		-	redução	gradual	na velocidade da animação;
	ease-in		- aumento gradual na velocidade da animação;
	ease-in-out  	- aumento gradual, depois redução gradual na velocidade da animação;
	cubic-bezier(x1,y1,x2,y2) - curva de velocidade para animação customizada (avançado)

3. Transition Color:

#teste{
	position:relative;
	top: 10px;
	color: white;
}

#teste:hover{
	top: 30px;
	color: red;
	transition: top 2s, color 1s ease;		
}

Podemos usar o atalho "All" para aplicar a mesma animação em todas as propriedade (que já é padrão):
	transition: all 1s ease;


ESPECIFICAÇÃO TRANSFORMS
Com esta especifiação podemos usar propriedades visuais dos elementos antes impossíveis. Por exemplo, agora podemos alterar o ângulo de um elemento, mostrar em escala maior ou menor que seu tamanho padrão ou alterar a posição do elemento sem alterar a sua estrutura.

1. Translate:
.header	{
    /*	Move	o	elemento	no	eixo	horizontal	*/
    transform:	translateX(50px);
}

#main	{
    /*	Move	o	elemento	no	eixo	vertical	*/
    transform:	translateY(-20px);
}

footer	{
    /*	Move	o	elemento	nos	dois	eixos	(X,	Y)	*/
    transform:	translate(40px,	-20px);
}

2. Rotate

.quadrado{
    width: 200px;
    height: 200px;
    background: chocolate;
    transform:	rotate(-20deg);
}


3. Scale
#novidades li	{
    /*	Alterar a escala total do elemento */
    transform:	scale(1.2);
}

#mais-vendidos li	{
    /*	Alterar	a escala vertical e horizontal do elemento */
    transform:	scale(1, 0.6);
}

4. Skew
footer	{
	/*Distorcer o elemento no eixo horizontal */
	transform: skewX(10deg);
}

#social	{
	/*Distorcer o elemento no eixo vertical	*/
	transform: skewY(10deg);
}

- É possível combinar várias transformações no mesmo elemento:
html{
	transform: rotate(-30deg) scale(0.4);
}


ESPECIFICIDADE DE SELETORES CSS

O comportamento padrão dos seletores, quando não há conflitos entre propriedades, é que as propriedades sejam acomulativas. Em caso de conflito, entre propriedades de seletores equivalentes, ou até em um mesmo seletor, é aplicada a propriedade declarada depois:

<p>Texto do parágrafo em destaque</p>
<p>Texto de um parágrafo comum</p>

1. Declaração sem conflito, propriedades declaradas acumuladas:

p {
    color: navy;
}

p {
    font-size: 16px;
}

Declaração com conflito, última propriedades declarada:
p {
    color: navy; <- continua aplicando 
    font-size: 12px; <- será anulada se declarada posteriormente por outro valor
}

p {
    font-size: 16px; <- valor que sobrescreverá, se houver algun valor antes declarado.
}


2. Seletor de Tag:
div {} - seletor genérico (toda tag div receberá os valores de atributos especificados aqui).

3. Seletor de Class:
.destaque{ } - seletor um pouco mais específico (decidimos quais elementos receberá os valores especificados aqui). O valor especificado aqui é maior que o valor de Seletor de Class.

4. Seletor de Id:
#destaque{ } - seletor bem específico (só pode ter um único elemento que receberá os valores específicados aqui). A especificidade do seletor Id é maior que o valor do Seletor de Class e Seletor de Tag.

ESPECIFICADADE
Podemos adicionar um ponto em cada posição do valor de um seletor para chegarmos ao seu valor de especificidade:

Podemos usar uma tabela para ajudar no reconhecimento desses valores:

VALORES DE ESPECIFICADE DE SELETORES
-------------------------------------------------------------------------
Seletor de ID			|  Seletor de Classe	     	|  Seletor de Tag   
Ex.: #rodape{font-size: 11pt}  	|  ex.: .conteudo{width: 960px}	|  ex.: div{color:green}
	1				      1				  1

	Seguindo os valores de especifidade da tabela acima, podemos calcular os valores de especifidade para qualquer CSS, por exemplo:

p{/*valor de especificidade: 001*/
	color: blue;
}

.destaque{/*valor de especificidade: 010 */
	color: red;
}
#cabecalho{/*valor de especificidade: 100 */
	color: green;
}

	Nos seletores combinados ou compostos, basta somar os valores em suas determinadas posições:

#rodape p{/* valor de especificidade: 101 */
	font-size: 11px;
}

#cabecalho .conteudo h1	{/* valor de especificidade 111	*/
	color: green;
}

.conteudo div p span{/* valor de especificidade: 013 */
	font-size: 13px;
}

	Quando maior a propriedade do seletor, maior é a propriedado do seu valor, dessa maneira o valor de especificidade 013 sobrescreve as propriedades conflitantes para o mesmo elemento que um seletor com o valor de especificidade 001.
	Essa é a maneira simples de descobrir qual seletor tem sua propriedade aplicadas com maior propriedade.

Nos limitaremos apenas nesses três, por hora.


WEB PARA DISPOSITIVOS MÓVEIS

SITE MOBILE OU MESMO SITE?

Fazer um site específico para dispositivos móveis ou fazer um site que se ajuste a qualquer dispositivo?

Web Única (One Web) - A melhor experiência para os usuários é ter o mesmo site Desktop normal também acessível no mundo móvel. 

CSS MEDIA TYPES

Há um tempo atrás havia uma preocupação com o layout de digerentes dispositivos, desde a época do CSS2. Para resolver esse tipo de problemas usava-se o recurso chamado de Media Type. Declarávamos as chamadas de cada arquivo de folha de estilo no head da página, como chamamos o css hoje, mas usávamos três chamadas para cada tipo ou criava tudo junto no mesmo arquivo de folha de estilo.


<link	rel="stylesheet" href="site.css" media="screen"	/>
<link	rel="stylesheet" href="print.css" media="print"	/>
<link	rel="stylesheet" href="handheld.css" media="handheld"	/>

Ou:

@media screen{
	body{
		background-color: blue;
		color:	white;
	}
}

@media print{
	body{
		background-color: white;
		color:	black;
	}
}

MEDIA TYPE SCREEN & MEDIA TYPE PRINT
Esse recurso, "media type screen", deternima a visualização normal no desktop. Era comum também fazer uso do "media type print", que permitia formatar recursos tipo textos e como seriam exibidos na impressão.

HANDHELD
Havia também o "handheld", voltado para dispositivos móveis. 
O problema era que os dispositivos na época eram simples (celulares wap e palmtops) e muito limitados. Era usado para páginas bem simples.

SCREEN
Quando começaram a surgir os novos smartphones, eles eram capazes de abrir páginas mais complexas, como o próprio desktop, por exemplo o IPhone. Por isso, o IPhone e outros celulares modernos ignoram o uso dos "handheld", e consideram, na verdade, "screen". 

A solução veio com o CSS3:

Todos os smartphones e navegadores modernos suportam uma nova forma de adaptar o CSS baseado nas propriedades dos dispositivos, as "media queries" do CSS3.

Invés de indicarmos que um determinado CSS é para um "handheld" em geral, podemos indicar que determinadas regras do CSS devem ser vinculadas a propriedades dispositivo como tamanho de tela, orientação (landscape ou protrait) e até resolução em dpi:

<link rel="stylesheet" href="base.css" media="screen">
<link rel="stylesheet" href="mobile.css" media="(max-width: 480px)">

Ou separar as regras dentro do mesmo CSS:

@media screen{
	body{
		font-size: 16px;
	}
}

@media(max-width:480px)	{
	body{
		font-size: 12px;
	}
}


o Atributo "media" agora recepe expressões mais complexas. Com isso, podemos definir o tamanho da fonte que queremos em uma determinada dimensão da tela em pixels por exemplo.

VIEWPORT - área de conteúdo dos smartphones. Área que abrange todo o conteúdo do site como no desktop.

Se tentarmos ver a página com as regras do exemplo de media screen anterior, veremos que nossa página é exibida como no desktop. Parece que as regras do "max-width" são ignoradas pelos dispositivos móveis. - Exatamento porque o Viewport considrea a área dos smartphones igual a do desktop, suportando todo o conteúdo do site assim como no desktop. 

Na verdades é que os smartphones tem telas grandes e resoluções altas, justamente para poder visualizar sites complexos feitos para desktop. A tela de um IPhone4, por exemplo, é formada por 960px por 640px. Celulares Androids já chegam a 1280px, o mesmo de um Dektop.

Ainda assim a experiência dos desktops são bem diferentes dos smartphones: 
1280px em uma tela de 4 polegadas é bem diferente de 1280px em um notebook de 13 polegadas. A resolução muda. Celulares costumam ter resolução em DPI bem maior que desktops.

DPI = (pixel por polegada)

Desktop = 1280px - dpi normal
Smartphone = 1280px - dpi superior ao desktop


DEVICE-WIDTH - define um padrão de pixels (dpi) padrão do frabricante do smartphone. 
 
Os smartphones sabem que considerar a tela com 1280px não ajudará o usuário a visualizar a página otimizadas para telas menores. Há então o conceito de "device-width" que, resumidamente, representa um número em pixels que o fabricante do aparelho considera como mais próximo da sensação que o usuário tem ao visualizar a tela.

Nos Iphones, por exemplo, o "device-width" é considerado como 320px, mesmo com a tela tendo a resolução bem mais alta.

Por padrão os IPhones e Androids costumam considerar o tamanho da tela visível, chamada de "viewport", como grande o suficiente para comportar os sites desktops normais. Por isso, no exemplo de @media, a nossa página foi exibida como se estivéssemos no desktop.

Por isso declaramos a tag: <meta name="viewport" content="width=device-width"> dentro da página index.

O que acontece quando a resolução for maior que 320px?

Nosso design volta a 940px e o scroll fica horizontal. A maioria dos smartphones tem 320px de largura, mas nem todos, e o nosso layout não se ajusta bem a esses outros. Quando giramos o aparelho a resolução passa a ser (480px no Iphone e mais de 500px em muitos Androids).

O melhor seria deixar nossas configurações entre 320px e 940px que estabelecemos para o site desktop.

Como fizemos um "layout fluido", baseado em porcentagens, os elementos se ajustam a diferentes resoluções sem esforços. É uma boa prática usar porcentagens, e sempre que possível, evitar o uso de valores absolutos em pixels.

RESPONSIVE WEB DESIGN

Ess prática aplicada, chamamos de "Web Desing Responsivo". O termo surgiu no famos artigo de Ethan Marcotte e diz exatamente o que acabamos de praticar. 

3 ELEMENTOS DE UM SITE RESPONSIVO

1. Layout fluido, usando medidas flexíveis, como porcentagens;
2. media queries para ajuste de design
3. Uso de imagens flexíveis.

A ideia do responsivo é que a página se adapte a diferentes resoluções. Embora o uso das procentagens seja uma prática antiga, foi a popularização dos "media queries" que permitiram layouts verdadeiramente adaptativos.

MOBILE-FIRST

Nosso layout até agora tem sido desenvolvido pensando primeiro no desktop e depois fizemos alguns ajustes, que por sinal, modificaram alguns propriedades que já havíamos feito. Na prática, isso não é muito interessante. 
É muito mais comum e recomendado o uso da prática inversa: "mobile-first". Isto é, começar o desenvolvimento pelo mobile e, depois, adicionar suporte a layout desktop.
Ma prática, usaremos mais media-queries, mais min-width ao invés de max-width, mais comum em códigos desktop-first.

1. Inicia-se o desenvolvimento pela área mais simples, com mais restrições, o mobile.
2. O uso da tela mais simples vai nos forçar a criar página mais simples, focada e objetiva.
3. Depois, com medias queries, readaptar o layout para desktop. 

A abordagem Dektop-first começa pelo ambiente mais livre e vai tentando cortar coisas quando chega no mobile. Na prática, é muito mais trabalhosa essa prática.

PROGRESSIVE ENHACEMENT E MOBILE-FIRST
 
Criando um form para a página compras:

Semanticamente, usaremos um componente html que nos permite adicionar uma legenda e os componentes do form em seguida <fieldset> </fieldset>que vem acompanhado do <legend></legend>

Ex.:
<form>
	<fieldset>
		<legend>Escolha	a cor</legend>
		<input	type="radio" name="cor" id="verde">
		<label	for="verde">Verde</label>
		<input	type="radio" name="cor" id="rosa">
		<label	for="rosa">Rosa</label>	
		<input	type="radio" name="cor" id="azul">
		<label	for="azul">Azul</label>
	</fieldset>
	<button	class="comprar">Comprar</button>
</form>

Desenvolver um site pensando na seguinte estrutura:

1. O Html - Sua função é estruturar o conteúdo da página de uma maneira semântica e acessível, provendo uma base de funcionalidades para a página sem relação imediata com o visual;

2. O CSS - e o visual dele são uma segunda camada, que vem em cima do HTML semântico e bem construído. 

3. Java Script  - Necessário para implementar outros recursos da página, não sendo obrigatório seu uso.

Esse tipo de pensamento é chamado de Progressive Enhacement - Construir uma base sólida, simples, portável e acessível e, depois, progressivamente, incrementar a página com recursos mais avançados tanto de estilo com CSS quanto de comportamento com JavaScript.


BOX MODEL E BOX-SIZING

Box Model padrão do W3C

Quando alteramos a propriedade de elementos dentro de uma página, precisamos pensar no comportamento desses elementos na presente um do outro.
Uma forma de entender o impacto causado pela mudança é pensar no box model.

1. Box Model - É constituído por quatro áreas retangulares: conteúdo(content), espaçamento(padding), bordas(border) e margens(margin), conforme imagem:

|------------------------------------------------|
|		    Margin 			 |
|  |---------------------------------------|	 |
|  | |--------------Border---------------| |     |
|  | |	|---------------------------|	 | | 	 |
|  | |	|	    Padding	    |	 | |	 |
|  | |	|    |-----------------|    |	 | |	 |
|  | |	|    |      Content    |    |    | |     |
|  | |	|    |-----------------|    |    | |     |
|  | |	|                           |    | |     |
|  | |  |---------------------------|	 | |	 |
|  | |-----------------------------------| |	 |
|  |---------------------------------------|     |
|						 |
|------------------------------------------------|


Essas áreas se desenvolvem de dentro para fora, na ordem abaix:

Conteúdo (content) - aquilo que será exibido;
Espaçamento (padding) - distância entre a borda e o conteúdo;
Borda  (border) - Quatro linhas que envolvem a caixa (box);
Margem (margin) - distância que separa um box de outro;

Tendo em mente o "box model", precisamos ter atenção na alteração de propriedades de um elemento visualizando o impacto em sua apresentação ao lidar com as propriedades listadas acima. 

2. Box-sizing 

Por padrão, todos os elementos têm o valor 'box-sizing: content-box' o que significa que o tamanho dele é definido pelo seu conteúdo apenas -- em outras palavras, é o tal box model padrão que vimos antes. Mas podemos trocar por 'box-sizing: border-box' que indica que o tamanho agora levará em conta até a borda - ou seja, o 'width' será a soma do 'content' com a 'border' e o 'padding'

Ou seja, o tamanho da forma é somado com o tamanho da borda, em outras palavras, a borda cresce pra dentro da forma.


Obs.: Ao desenvolver mobile-first, usamos muitas media queries do tipo 'min-width' para implementar as mudanças para o tablet/desktop.

MEDIAS QUERIES - QUERIES DE CONTEÚDO

O valor que colocamos dentro dos medias queries são chamados de "breakpoints", os pontos onde o layout será ajustado no site por causa de uma resolução diferente. 

Design responsivo questiona o seguinte:
Quais os valores padrões a se colocar nos media queries?
320px, 480px, 600px, 768px, 992px, 1200px (chamamos isso de "device-driven breakpoint") - são valores gerados a partir de tamanhos de dispositivos.   

Devemos evitar essa lista de breakpoint, essa lista tráz uma meia dúzia de dispositivos, mas não atende todos (e os 360px de um Galaxy S4?). 
Usar esses valores garante apenas que a responsividade funcionará nos dispositivos específicos, nos dispositivos "padrões".

Dar preferência aos nossos breakpoints com valores baseados em nosso conteúdo, garante que nossa página funcione em todos os dispositivos.

Na prática, podemos redimensionar a janela e anotar os valores (quebrados ou não) onde o layout quebre ou fique feio, à partir daí, fazer os próprios breakpoints.


BOOTSTRAP E FRAMEWORK CSS

FORMULÁRIO
1. Atributos do Form: 
<form action="/efetivar.html" method="POST"></form>

Atributos:
 - action: Obrigatório. Esse atributo é o endereço para onde enviaremos os valores dos campos que estiverem dentro desse formulário. Como esses valores são recebidos, depende de como é feita a aplicação do lado do servidor.

 - method: Especifica o método HTTP pelo qual essa informação será transmitida. 
	Valores:
	- POST: de maneira simplista, significa que queremos inserir as informações desse formulário, salvá-la de alguma maneira.
	- GET: é utilizado quando queremos obter alguma coisa a partir das informações que estamos transmitindo, por exemplo, um formulário de busca.
  
Compotentes do Form:
 - Label: é ligado ao <input> através do atributo "for" com o nome do input:
Ex.: 	<label for="nome">Nome:</label>
	<input type="text" name="nome" id="nome">

Dessa forma quando clicamos no label, o acampo interligado será ativado para que possamos interagir com ele.

 - Input: Tipos (type)
	- text: 
		<input	type="text" name="nome_usuario">
	- password: 
		<input	type="password" name="senha">
	- checkbox: 
		<input	id="contrato" name="contrato" type="checkbox" value="sim">
		<label	for="contrato">Aceito	os	termos	do	contrato.</label>
	- radio:
		<input	type="radio" name="idade" id="idade5" value="5">
		<label	for="idade5">Menos	de	5	anos</label>
		<input	type="radio" name="idade" id="idade10" value="10">
		<label	for="idade10">Menos	de	10	anos</label>
		<input	type="radio" name="idade" id="idade15" value="15">
		<label	for="idade15">Menos	de	15	anos</label>
		<input	type="radio" name="idade" id="idade20" value="20">
		<label	for="idade20">Menos	de	20	anos</label>
	- image:
		<input	type="image" name="botao" src="images/enviar.png" alt="Botão para enviar o formulário" width="20" height="18">
	- file:
		<input	type="file" name="anexo">
	- hidden:
		<input	type="hidden" name="codigo" value="abc012xyz789">
	- button:
		<input	type="button" name="mostra_dialogo" value="Clique aqui!">
	- submit:
		<input	type="submit" name="enviar" value="Enviar">
	- reset:
		<input	type="reset" name="reset" value="Limpar">

	- textarea: 
		<textarea name="texto"></textarea>
	- Select, Optgroup e Option:
		- Estilo menu dropdown (seleciona uma opção):
		<select	name="cidades">
			<option	value="bsb">Brasília</option>
			<option	value="rj">Rio	de	Janeiro</option>
			<option	value="sp">São	Paulo</option>
		</select>
		
		- Estilo multipla seleção:
		<select	name="cidades" multiple>
			<option	value="bsb">Brasília</option>
			<option	value="rj">Rio	de	Janeiro</option>
			<option	value="sp">São	Paulo</option>
		</select>
			
		Caso necessário, dependendo do número de opções apresentadas ao usuário, pode ser interessante agrupá-las:
		<select	name="bairro">
			<optgroup label="Brasília">
				<option	value="asan_bsb">Asa Norte</option>
				<option	value="asas_bsb">Asa Sul</option>
			</optgroup>
			
			<optgroup label="Rio de Janeiro">
				<option	value="botafogo_rj">Botafogo</option>
				<option	value="centro_rj">Centro</option>
			</optgroup>

			<optgroup label="São Paulo">
				<option	value="vlmariana_sp">Vila Mariana</option>
				<option	value="centro_sp">Centro</option>
			</optgroup>
		</select>

NOVOS COMPONENTES HTML 5
Button types:
	- email - exibe teclado ou pções de e-mail nos smartphones:
		<input	type="number" max="100" step="5">
	- number - exibe um campo com setas para encrementar ou decrementar valor do campo, e valores múltiplos:
		<input type="number" max="100" step="5">
	- url - exibe teclado com opções para e-mail (www, .com. etc)
		<input type="url" name="endereco">
	- range - exibe controle deslizante para uso de valores numéricos em escala.
		<input	type="range" name="volume">
	- date, month, week, time, datetime e datetime-local - "date picker" são feitos para coletar uma informação de data e hora:
		<input	type="date" name="validade">
	- color - exibe um espectro (color picker) para seleção de cor:
		<input	type="color" name="cor_olhos">
	- search - Exibe um campo específico para busca. O atributo "results" determina quantas últimas buscas armazenadas e lembradas. Além de exibir uma lupa dentro do campo (Chrome e Safari).
		<input	type="search" results="10">
	- tel - coleta um número de telefone, permite usar teclados com informações relevantes apenas a esse tipo de entrada:
		<input	type="tel" name="telefone">


NOVOS ATRIBUTOS HTML 5 DENTRO DE ELEMENTOS DE FORMULÁRIO

	- autofocus - indica que aquele campo deve ser iniciado com o foco quando a página for carregada. 
		<input	type="text" name="nome" autofocus>

	- placeholder - exibe um texto informativo dentro do campo caso ele esteja vazio.
		<input type="text" name="nome" placeholder="Insira seu nome">

	- autocomplete, list e datalist - permite implementar uma funcionalidade de sugestão de valores para autocompletar um campo:
		<input type="text" list="cidades" autocomplete="on">
		<datalist id="cidades">
			<option	value="Brasília">
			<option	value="Rio de Janeiro">
			<option	value="São Paulo">
		</datalist>
	Obs.: Sem o list definido, mas com o automplete ligado, o campo exibirá dados digitados em outros campos para complementá-lo.

	
ÍCONES
	Biblioteca para ícones:

	- Font Awesome
	- Iconic
	- Octicons

VALIDAÇÕES
	- required - validação fraca, do lado cliente.
	- pattern - definimos entrada de valores através de expressões.
		- <input type="text" pattern="^@\w{2,}" name="usuario_twitter">
	
	1. Estilizando campo quando o valor for inválido: usando pseudo código:
		.form-control:invalid{
			border: 1px solid #CC0000;
		}

GRID RESPONSIVO DO CSS
Para facilitar o posicionamento de objetos foi desenvolvido um método, que facilita o uso de design multi coluna, chamado de grid. Os frameworks CSS, geralmente, possuem os grids prontos para utilização, pois já vem com as classes prontas. Basta usar as classes certas.
O Bootstrap possui várias dessas classes prontas.

O grid Bootstrap trabalha com o conceito de 12 colunas, permitindo escrever o código escolhendo quantas colunas nós queremos ocupar:

| .col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 |.col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 | 
| .col-md-8                                                                                    | .col-md-4                                     |
| .col-md-4                                     | .col-md-4                                    | .col-md-4                                     |
| .col-md-6                                                             | .col-md-6                                                            |


<div class="row">
	<div class="col-md-4">
		div ocupa 4/12
	</div>
	<div class="col-md-8">
		div ocupa 8/12
	</div>
</div>

a class Row é necessária para que o layout funcione corretarmente:

- Podemos criar grids dentro de grid, sempre obedecendo a divisão de 12 colunas:

<div class="row">
	<div class="col-md-4">
		...
	</div>
	
	<div class="col-md-8">
		<div class="row">
			<div class="col-md-6">
				...
			</div>
			<div class="col-md-6">
				...
			</div>
		</div>
	</div>
</div>

- RESPONSIVIDADE DO GRID:

col-	:	Extra	small	<	576px
col-sm-	:	Small	>=	576px
col-md-	:	Medium	>=	768px
col-lg-	:	Large	>=	992px
col-xl-	:	Extra	large	>=	1200px 

Podemos aplicar mais de uma classe no mesmo elemento:

<div class="row">
	<div class="col-xs-6 col-sm-4">
		...
	</div>
	<div class="col-xs-6 col-sm-8">
		...
	</div>
</div>

DADOS CUSTOMIZADOS HTML 5

	Até o HTML 4, não havia uma forma padronizada de colocar atributos customizados. 
À partir do HTML 5, atributos começando com "data-" em qualquer tab são considerados atributos customizados e não quebram a validade do HTML. Esses atributos são bastante úteis para passar informações como para um código Java Script.

	<button	class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarToggleExternalContent">


OUTROS FRAMEWORKS CSS

	- Foundation - Da Zurb, fortemente baseado em mobile e responsivo. http://foundation.zurb.com/
	- Semantic UI - Tem nomes de classes mais simples e semânticos que os outros. http://semanticui.com/
	- Pure - Do Yahoo, outra alternativa, mais recente. http://purecss.io/


Exemplos:

<!-- Bootstrap -->
	<button	class="btn btn-primary btn-lg">Clique aqui</button>

<!-- Foundation -->
	<button	class="large button">Clique aqui</button>

<!-- Semantic UI -->
	<button	class="large ui button">Clique aqui</button>

<!-- Pure -->
	<button class="pure-button pure-button-primary pure-button-large">
		Clique	aqui
	</button>


JAVA SCRIPT E INTERATIVIDADE NA WEB

<output> - essa tag representa a saída de algum cálculo ou valor simples obtido a partir de um ou mais campos de um formulário. Ele possui um atributo for que aponta de qual elemento saiu o seu valor.

	<output	for="tamanho" name="valortamanho">42</output>

Basicamente é como se fosse uma div simples, podendo ser formatada futuramente. A grande sacada é o valor semântico da tag e o que ela representa.

Usaremos esse componente para vincular a alteração feita na barra deslizante de (tamanho) para que esse valor seja modificado conforme deslizamos o componente.

Mudar o conteúdo de uma tag conforme o usuário modifica o valor no componente, não é função do HTML, por isso, usamos o Java Script.

HISTÓRIA DO JAVA SCRIPT
- Tudo começou com a necessidade de ter que tornar as páginas de navegação na internet mais dinâmicas, ou seja, uma interação maior com o usuário com as páginas. 
- Entra a Netscape, a criadora do navegador mais popular do mundo nos anos 90, de mesmo nome, criou o LiveScript, uma linguagem simples que permitia o uso de scripts dentro da própria página.
- No mesmo instante em que Java crescia no mercado, a Netscape logo rebatizou o LiveScript como JavaScript num acordo com a Sun para alavancar as duas.
- Foi quando, a atual líder do mercado, Microsoft, adicionou ao Internet Explorer o suporte a script escritos em VBScript e criou sua própria versão de JavaScript, o JScript.

CARACTERÍSTICAS DO JS
- O JavaScript, é uma linguagem de 'scripting'
- Linguagem Scripting é uma linguagem que permite controlar uma ou mais aplicações de terceiros.
- Normalmente, elas são linguagens 'interpretadas', ou seja, precisam ser compiladas. No navegador, o código é lido e intrepretado conforme é lido pelo navegador, linha à linha, conforme o HTML.
- JavaScript possui uma grande tolerância a erros, ou seja, nem sempre o erro mostra um comportamento diferente.
- O JS é enviado, pelo navegador, junto com HTML. Para que o navegador saiba diferenciar HTML de JS, é preciso envolver o código JS dentro das tags <script></script>

CONSOLE
É um componente que acompanha grandes números de navegadores, e servem para debugar o código fonte da página, inclusive auxiliando nos códigos Java Script.


AUTOMATIC SEMICOLON INSERTION (ASI) - "INSERÇÃO AUTOMÁTICA DE PONTO E VÍRGULA"

O ponto e vírgula é fundamental e não pode ser omisso no final de cada linha em JS devido o mecanismo chamado (ASI).

SEPARANDO O ARQUIVO JS DO HTML
<script	type="text/javascript" src="js/hello.js"></script>

var mensagem = "Olá mundo";
alert('mensagem'); - exibe a mensagem para usuários.
console.log(mensagem); - imprime o conteúdo escodido no console. 

Quando o console estiver aberto, não há necessidade de usar console.log para chamada de mensagem, basta chamar a variável.

DOM - PÁGINA NO MUNDO JAVASCRIPT

Para permitir alterações na página, ao carregar HTML da página, os navegadores carregam em memória uma estrutura de dados que representam cada uma de nossas tags no JavaScript. Essa estrututura é chamada de DOM ( Document Object Model ). Essa estrutura pode ser acessada pela variável global Document.
Document é o termo usado para as nossas páginas.

document.querySelector("h1"); - Pegar uma tag
document.querySelector(".class"); - pegar o valor de uma class
document.querySelector("#id"); - pegar o valor de um ID

- querySeletor

ELEMENTO DA PÁGINA COMO VARIÁVEL

- Pegando o valor de uma tag e atribuíndo em uma variável:
var titulo = document.querySelector("h1");

- Visualizando o conteúdo da tag pela variável:
titulo.textContent;

- Alterando o conteúdo da tag:
titulo.textContent = "Novo título";


QUERYSELECTORALL

document.querySelectorAll(".card") - exibe a tag chamada e seus filhos e netos...
document.querySelectorAll(".card")[0] - exibe o filhos e netos da tag chamada, chamando os elementos desse array dentro de colchete começando do 0

ALTERAÇÕES DO DOM
Ao alterarmos os elementos da página, o navegador sincroniza as mudanças e alteram a aplicaçao em tempo real.

FUNÇÕES E OS EVENTOS DO DOM
Podemos alterar o documento todo através do JavaScript, podemos fazer alterações de um conteúdo clicando em botão ou quando e não quando carregamos a página.
O problema é que todos código colocado dentro de <script> o html lê logo que a página é carregada.

Para guardarmos um código para ser executado eventualmente, precisamos usar alguns recursos. Para isso começaremos criando uma função:

- Criando a função:
function mostraAlert(){
	alert("Funciona!");
}                                       

Ao criarmos uma função o código dentro dela fica guardado e só será executado quando chamado em algum evento de click, por exemplo, quando chamamos a função.

- Chamando a função: 
mostraAlert();

- Atribuíndo a propriedade ID do botão à variável botão
//obtendo um elemento através de um seletor de ID
var botao = document.querySelector("#botaoEnviar");

- Chamando a função pelo evento no botão:

botao.onclick = mostraAlert;


EVENTOS DO MOUSE:

oninput: quando um elemento input tem seu valor modificado
onclick: quando ocorre um click com o mouse
ondblclick: quando ocorre dois clicks com o mouse
onmousemove: quando mexe o mouse
onmousedown: quando aperta o botão do mouse
onmouseup: quando solta o botão do mouse (útil com os dois acima para gerenciar drag'n'drop)
onkeypress: quando pressionar e soltar uma tecla
onkeydown: quando pressionar uma tecla
onkeyup: quando soltar uma tecla
onblur:	quando um elemento perde foco
onfocus: quando um elemento ganha foco
onchange: quando um input, select ou textarea tem seu valor alterado
onload:	quando a página é carregada
onunload: quando a página é fechada
onsubmit: disparado antes de submeter o formulário (útil para realizar validações)

Existem uma série de Eventos mais avançados como por exemplo: drag-and-drop, e até mesmo criação de eventos customizados.

FUNÇÕES	ANÔNIMAS

Antes, com a função, seria assim:
	USANDO A FUNÇÃO EM QUALQUER PARTE DO CÓDIGO: (caso queira usar a mesma função diversas vezes em pontos diferentes do código).

	- Nesse caso indicamos a função: "mostraTamanho" que será executada no momento em que alterarmos o valor em <input type="range">.
	Não estamos executando a função "mostraTamanho()", já que não colocamos parênteses. Apenas está sendo indicado o nome da função que queremos executar: 
	
	inputTamanho.oninput = mostraTamanho;
	
	function mostraTamanho(){
		outputTamanho.value = inputTamanho.value;
	}

	USANDO A FUNÇÃO EM APENAS UMA PARTE DO CÓDIGO: (no caso de uso exclusivo e específico em apenas um uso da função).
	- Há algum outro lugar do código no qual precisamos chamar essa função? Não! Por isso damos nome à uma função, para que possamos usá-la em qualquer outra parte do código. 
	- Também é muito comum que uma função tenha apenas uma chamada no código. Nesse caso, o JS permite que criemos uma função no lugar do nome dada a ela: 
	- Nesse caso, transformamos "mostraTamanho" em uma função sem nome, uma função anônima. 

	inputTamanho.oninput = function() {
		outputTamanho.value = inputTamanho.value
	}
	

MANIPULANDO STRINGS

Uma variável que armazena um string faz muito mais que isso! Com isso podemos consultar seu tamanho e transformar seus valores.

var empresa = "C&B";
empresa.lenght; //tamanho da string
empresa.replace("B","A"); //Retorna C&A

CONVERSÕES

	Podemos converer strings para numbers:

var textoInteiro = "1000";
var inteiro = parseInt(textoInteiro);

var textoFloat = "10.22";
var float = parseFloat(textoFloat);

MANIPULANDO NÚMEROS

	Number, assim como String, também é imutável. O exemplo abaixo altera o número de casas decimais com função toFixed. Esta função retorna uma string, mas, para ela funcionar corretamente, seu retorno precisa ser capturado:

var milNumber = 1000;
var milString = milNumber.toFixed(2); //recebe o retorno da função
console.log(milString); //imprime a string "1000.00"

CONCATENAÇÕES

	É possível juntar tipos diferentes e o JavaScript se encarregará de realizar a conversão entre os tipos, podendo resultar em algo não esperado.

- String com String:
	var s1 = "Teste: ";
	var s2 = "Contatenação";
	console.log(s1+s2);//Imprime "Teste Concatenação"

- String com outro tipo de dados:
	var num1 = 2;
	var num2 = 3;
	var nome = "Teste";

	console.log = num1+num2; \\retorna 5
	console.log = num1+nome; \\retorna 2Teste
	console.log = num1+nome+num2; \\retorna 2Teste3
	console.log = nome+(num1+num2); \\retorna Teste5
	console.log = nome+num1*num2; \\retorna Teste6

NaN - Not a Number
	Esse resultado indica que todas operações matemáticas, exceto subtração, só podem ser feitas com números. O valor NaN possui uma peculiaridade, definida em suas especificações.
Exemplo: 
	console.log(10-"curso") \\retorna NaN
	var resultado = 10-"curso";
	resultado == NaN;
	NaN == NaN;

Obs.: Não é possível comparar NaN com NaN. Para saber se uma variável é NaN, deve ser usada a função isNaN:
	var resultado = 10-"curso";
	isNaN(resultado);//true;


ARRAY
É útil para quando quisermos trabalhar com vários valores armazenados.

Ex.: 
var palavras = ["Curso","JavaScript"]; //Criar um array com chaves e valores : 0 => Curso,1 => JavaScript;

push.palavras("HTML"); //Adiciona uma nova chave e valor em sequência no array específico.

Também podemos guardar valores diferentes: 

var variosTipos = ["Curso", 10, [1,2]]; 

Array tem seu tamanho definido de 0 até -1, podemos obter os valores chamando o array e especificando a chave da posição do valor:

console.log(variosTipo[0]) //Imprime "Curso"
console.log(variosTipo[1]) //Imprime 10
console.log(variosTipo[2]) //Imprime [1,2]

	1. ADICIONANDO ELEMENTO PELO ÍNDICE:
	
	Invés de usar o Push, que adiciona o valor no último elemento do array, podemos especificar a ordem que desejamos inserir o valor:

var palavras=["Curso","HTML"];
palavras[9] = "JavaScript;

console.log(palavras[0]) //Imprime "Curso"
console.log(palavras[1]) //Imprime "HTML"
console.log(palavras[...]) //Imprime undefined
console.log(palavras[9]) //Imprime JavaScript

Dessa forma aumentamos o tamanho do array para 10 e incluíremos o valor na posição 10, com isso, as posições intermediárias ficarão com o valor undefined.

Obs.: O tamanho de um array é dinâmico. Sendo assim podemos inserir qualquer valor, quantas vezes quisermos e ele ajustará seu tamanho quando necessário.

BLOCO DE REPETIÇÃO

	Imagina que queremos desenvolver uma série de repetição para um código, repetida vezes até que a condição seja comtemplada, ou enquanto ela for verdadeira.
	O mais comum é o "for":

	1. FOR - Precisa de alguma condição para que sua execução não se repita infinitamente.

for(/*variável de controle*/ ; /* condição */ ; /* pós execução */ ){
	//código a ser repetido
}

Das informações necessárias, somente a condição é obrigatória, mas normalmente utilizamos todas as informações:

var palavras = ["HTML", "CSS"];

for(var i = 0 ; i < palavras.length ; i++ ){
	alert(palavras[i]);
}

	2. WHILE - Executa determinado código repetitivamente enquanto uma condição for verdadeira. Diferente do bloco for, a variável de controle, bem como sua manipulação, não são responsabilidade do bloco em si.

var contador = 1

while( contador <= 10 ){
	alert(contador + " Teste");
	contador++;
}

alert("Valor do contador: " + contador);


FUNÇÕES TEMPORAIS
	Em JavaScript, podemos criar um "timer" para executar um trecho de código após um certo tempo, ou ainda executar algo de tempos em tempos.

	A funão  "setTimeout" permite que agendemos alguma função apara execução no futuro e recebe o nome da função a ser executada e o número de milissegundo a esperar:

	//executa a minhaFuncao daqui um segundo
	setTimeOut(minhaFuncao, 1000);

	Se for um código recorrente, podemos usar o setInterval que recebe os mesmos argumentos mas executa a função indefinidamente de tempos em tempos:

	//executa a minhaFuncao de um em um segundo
	setInterval(minhaFuncao, 1000);

Obs.: É uma função útila para implementação de um banner rotativo, por exemplo.

	
	As funções temporais devolvem um objeto que representa um agendamento que foi feito. É possível usá-lo para cancelar a execução no futuro. É especialmente interessanto no caso do "interval" que pode ser cancelado de sua execução infinita:

	//agenda uma execução qualquer
	var timer = setInterval(minhaFuncao, 1000);

	//cacela execução
	clearInterval(timer);


ONCLICK E ONSUBMIT OU ADDEVENTLISTENER

Na função abaixo, usamos o "onclick" com "onsubmit" no mesmo elemento sendo manipulado:

	document.querySelector('#destaque').onclick = function() {
		//tratamento do evento
	};

	- É uma forma fácil e portável de tratar eventos;
	- O maior problema é que só podemos atrelar uma única função ao evento.
	- Colocar uma segunda função no para executar no mesmo evento, ele sobrescreverá a anterior.

A maneira mais recomendada de se associar uma função a eventos é o uso do AddEventListener:

	document.querySelector('#destaque').addEventListener('click', function() {
		//tratamento do evento
	});
	
	- Dessa forma, conseguimos adicionar vários listeners ao mesmo evento, deixando o código mais flexível. A desvantagem é que esse evento não funciona no IE8.
	- Para funcionar no IE8 ou anterior, usamos o seguinte evento:
	
	document.querySelector('#destaque').attachEvent('onclick', function() {
		//tratamento do evento
	});

	
	- O problema é que sempre deveremos usas as duas coisas para manter a compatibilidade.

Essa questão pode ser resolvida pelos famosos Frameworks JavaScript, como o jQuery.

CONTROLANDO VALIDAÇÕES HTML 5

O navegador possui opções padrões, e nem sempre é o que precisamos em nossa página. Podemos mudar esse comportamento ou personalizar para deixar da forma que queremos.

Usando o JavaScrip, podemos desabilitar a validação de campos, por exemplo, e fazer a nossa própria.

<script	type="text/javascript">
	document.querySelector('form input').oninvalid = function(event) {
 		//cancela comportamento padrão do browser
		event.preventDefault();
	
		//verifica a validade e mostra o alert
		if(!this.validity.valid){
			alert("Nome obrigatório!");
		}
	};
</script> 


JQUERY 
	JQuery é uma biblioteca JavaScript que traz diversas soluções que facilitam a vida do programador. Funcionalidades que se tornariam difíceis de serem executadas usando o JavaScript puro.
	Além disso, suas funções traz uma maior compatibilidade com a maioria dos navegadores, permitindo assim, ao programador, desenvolver códigos únicos para todos os navegadores.
	O terceiro ponto que acrescetarei aqui é que, além de JQuery ser uma linguagem padrão na programação de Front-end para Web, ele traz, também, uma funcionalidade padrão que é selecionar um elemento e alterar seu conteúdo. 
	
JQUERY - FUNÇÃO $

	JQuery possui um grande número de funções que facilitam a nossa vida. A mais importante delas, inicia a maioria dos códigos, é a função $. Com ela é possível selecionar qualquer elemento, com maior compatibilidade, e com menos código.

Exemplo:
	//JavaScript "puro":
	var cabecalho = document.querySelector("#cabecalho");

	if(cabecalho.attachEvent){
		cabecalho.attachEvent("onclick", function(event){
			alert("Você clicou no cabeçalho, usuário de IE!");		
		)}
	}else if(cabecalho.addEventListener){
		cabecalho.addEventListener("click", function(event){
			alert("Você clicou no cabeçalho!")
		}, false);		
	}

	//JQuery
	$(#cabecalho).click(function(event){
		alert("Você clicou no cabeçalho!");
	});
	

	No JQuery o código é bem menor, e o resto, a biblioteca se encarrega de o modo mais compatível possível para adicionar o evento ao elemento com o nome específico, no caso: #cabecalho.
	- Existem diversas funções que o JQeury possui e que nos permite aplicar ao elemento especificado na função $, ou seja, a função pode ser encadeada:

$("#cabecalho").css({"margin-top" : "20px", "color" : "#333"})
	.addClass("selecionado");

	Note que:
	1. Chamamos a função $ e passamos como argumento uma string com o nome do seletor;
	2. Chamamos a função CSS e, passamos um objeto como argumento, idêntico ao utilizado dentro do CSS. Isso será passado como atributos ao seletor que especificamos na função $;
	3. Chamos mais uma função, a addClass, que vai adicionar o valor "selecionado" ao atributo class do elemento com id cabecalho. 


JQUERY SELECTORS
	Uma grande vantagem de se usar JQuery é que podemos selecionar elementos a partir de seletores CSS. 
	Com CSS vimos como alterar de várias formas um elemento, mas nem todos os navegadores funcionam.
	Contudo, no JQuery, temos todos à nossa disposição.

	Por exemplo, se quisermos esconder todas as tags <td> filhas de um <tbody>, basta fazer o seguinte:

	$('tbody td').hide();

	1. SELETORES MAIS COMUM
	//Pintar o fundo do formulário com ID "form" de preto
	#('#form').css('background':'black');

	//esconde todos os elementos com o atributo "class" igual a "headline"
	#('.headline').hide();

	//muda o texto de todos os parágrafos
	$('p').text('Alô :D');

	Mais exemplos:
	$('div > p:first'); //o primeiro elemento <p> imediatamente filho de um <div> 
	$('input:hidden'); //todos os inputs invisíveis 
	$('input:selected'); //todos os checkouts selecionados 
	$('input[type=button]'); //todos os inputs com type="button" 
	$('td, th'); //todas as tds e ths 
	
	A função que chamamos após o seletor é aplicada para todos os elementos retornados. Exemplo:
	
	//forma ineficiente
	alert( $('div').text() + $('p').text() + $('ul li').text() );

	//forma eficiente
	alert($('div, p, ul li').text());

	A função text() é chamada para todas as tags: <div>s, <p>s, <ul>s e filhos seguidos: <li>		

	FILTROS CUSTOMIZADOS E POR DOM
	
	Existem diversos seletores herdados do CSS que serevem para selecionar elementos baseados no DOM. 
	Vejamos alguns:

	$('div > p'); //<p>s imediatamente filhos de <div>
	$('p + p'); //<p>s imediatamente precedidos por outro <p>
	$('div:first-child'); //um elemento <div> que seja o primeiro filho 
	$('div:last-child'); //um elemento <div> que seja o último filho
	$('div > *:first-child'); //um elemento que seja o primeiro filho direto de uma <div>
	$('div > *:last-child'); //um elemento que seja o último filho direto de uma <div>
	$('div p:nth(0)'); //o primeiro elemento <p> filho de uma <div>
	$('div:empty'); //<div>s vazias 

UTILITÁRIOS DE ITERAÇÃO DO JQUERY
	
	O Jquery possui uma função que permite trabalhar com array de forma bastante interessante, pois permite interagir com array de forma mais agradável.

$("#menu-departamentos li").each(function (index, item){
	alert(item.text);
})	

	A função "each" chamada logo após um seletor executa a função que passamos como argumento para cada um dos itens encontrados ( chamamos de callback - função que usa outra função para executar uma rotina ). Essa função precisa de dois argumentos:o primeiro será o "índice" do elemento atual na coleção (0 para o primeiro, 1 para o segundo e assim sucessivamente), e o segundo será o próprio elemento.	
	
	Nesse caso, note que chamamos a função each logo após a função $ , pois essa implementação é um método do próprio objeto $. Passamos dois argumentos, o primeiro é o array que iremos percorrer e o segundo a função que desejamos executar para cada um dos itens do array.
	
	Outro exemplo, bem prático, seria usar essas funções para listar ítens de uma <ol>:
Lista HTML:
<ol id="my-list">
  <li>Red</li>
  <li>Green</li>
  <li>Yellow</li>
  <li>Blue</li>
</ol>

Chamada da Função:
$('#my-list li').each(function(index, element) {
 console.log(index + ' : ' + element.innerHTML);
});


Saída:
0 : Red
1 : Green
2 : Yellow
3 : Blue

CARACTERÍSTICAS DE IMPORTAÇÃO

	1. Importação
	Antes de mais nada devemos inserir o JQuery em nossa página para que os códigos possam ser lidos em nossa página. Por isso é necessário que a linha de importação do JQuery seja a primeira de todas na importação dos scripts JS.

<script	type="text/javascript" src="scripts/jquery.js"></script>
<!-- só podemos utilizar o jQuery após sua importação -->
<script	type="text/javascript" src="scripts/meuscript.js"></script>
<script	type="text/javascript" src="scripts/meuoutroscript.js"></script>

	2. Executar somente após carregar

	Como estamos alterando as características dos elementos, é necessário verificar e ter a certeza que esses elementos estão sendo carregados pelo navegador.

	Podemos garantir isso executando o script após o término do carregamento total da página com a função $ da seguinte forma:

	$(function() {
		$("#cabecalho").css({"background-color" : "#000000"});
	})
	
	Essa função que recebe uma função anônima como argumento garante que o código dentro dela seja executado ao fim do carregamento de todos os elementos da página.

	TÉCNICAS DE IMPLEMENTAÇÃO
	1. É muito bom fazer com que mais ítens da página sejam exibindo clicando em ítens na tela, ou simplesmente, passando o mouse sobre o elemento.

TOGGLECLASS
	Funciona como um 'if e else' para verificar se uma classe já existe ao ser chamada em uma função ou não:
Por exemplo, um botão que clicamos uma vez para adicionar uma classe em uma div para exibir um conteúdo, e se clicar novamente ele deve ocultar, mas para isso precisaremos verificar se a classe já se encontra naquele componente:

	Exemplo:

	$('.novidades	button').click(function() {
		$('.novidades').toggleClass('painel-aberto');
	});

PLUGINS JAQUERY
	Além de usar os componentes JavaScript que já vêm prontos no Bootstrap, também podemos baixar outros plugins feitos para JQuery ou para Bootstrap que trazem novas funcionalidades. 
	
	O JQuery é rico em plugins disponíveis, inclusive no próprio site há um diretório recheado de plugins: https://plugins.jquery.com/tag/jquery/
	
	Cada plugin é um arquivo JavaScript que você adiciona à página e adiciona uma funcionalidade específica. Alguns necessitam de alteração no código, outros já são mais plug and play.  (é necessário consultar a documentaçã do plugin específico).

	Exemplo, máscaras numéricas:
	1. Baixamos e instalamos o plugin na pasta js:
	2. Na página específica chamamos o plugin no final da página:
	<script	type="text/javascript" src="js/inputmask-plugin.js"></script>
	3. Cada campo que desejarmos acionar essa máscara, devemos adicionar os atributos:
		- para CPF: data-mask="999.999.999-99"
		- para Cartão com código de verificação: data-mask="9999 9999 9999 9999 - 999"

INTEGRAÇÕES COM SERVIÇOS WEB

	1. Web 2.0 e Integrações

	Boa parte do grande poder da Web, de estarmos conectados o tempo todo, é o de permitir a integração entre as páginas. A Web nasceu com esse conceito, de tudo interligado através de links.

	Mas a tal Web 2.0 trouxe ideias ainda mais complexas. Interligar páginas e serviços diferentes, criando novos resultados através de novas páginas. 

	Podemos ver mapas do Google maps espalhados em vários sites por aí. Ou os onipresentes botões de curtir do Facebook. E muitos outros exemplos.

	2. IFRAMES
	Uma das formas de fazer esse tipo de integração é com o uso da tag <iframe>. Ela nos permite embutir o conteúdo de uma outra página no meio da nossa muito facilmente.
	
	<iframe src="outrapagina.html"></iframe>

	Podemos incluir páginas internas ou externas. E quando se trata de externas é fácil de usar esse recurso para incluir componentes reaproveitáveis de outros serviços. Como mapas.

	3. Vídeos do Youtube 
	O Youtube provê uma integração muito fácil com nossas páginas. Podemos incluir qualquer vídeo para ser tocado diretamente em nossa página.
	Basta entrar no youtube e copiar o endereço de um <iframe> que eles disponibilizam para ser embutidos em nossas páginas. 

FONTES CUSTOMIZADAS COM @FONT-FACE

	Fontes na web sempre foram um problema. Só podemos declarar no fonte familly aquelas que estão na máquina local, o que restringe bastante a opção.

	Desde o CSS2.1 ficou possível usar fontes declarando a propriedade @font-face indicando a URL onde o navegador pode baixar aquela fonte.

	@font-face{
		font-family: "Minha Fonte";
		src: url("minhafonte.ttf);
	}
	
	Essa funcionalidade existe desde o Internet Explorer 4.

	Mesmo assim, ainda nos deparamos com problemas de incompatibilidade. O suporte aos navegadores ainda é um grande problemas. Cada um suporta um tipo de arquivo. Fontes true type, por exemplo, padrão entre designers, só é suportado através do IE9. 
	- O IE usava fontes no formato EOT;
	- Outros navegadores TTF;
	- O iPhone só SVG;
	- E surgiu o terceiro, o WOFF, que agora faz parte da especificação.


SERVIÇOS DE WEB FONTS

	Lidar com essas diferenças entre navegadores é um problema, sem contar o fato de conseguir a legalidade das fontes em serviços e formatos corretamente e otimizado.

	Ultimamente alguns serviços de terceiros dominaram a Web, e oferecem infraestrutura necessária para usarmos as fontes na Web sem problemas e sem a necessidade de instalação. As fontes são sevidas direto do servidor de serviço em uso de maneira correta e rápida.

	Exemplos: http://typekit.com/
	
	É um serviço pago, mas com preços acessíveis e planos com todo tipo de fonte. Além do catálogo imenso com fontes famosas e em alta definição.

	A alternativa gratuita e mais famosa a ferramenta do Google Web Fonts: https://www.google.com.br/fonts

	É provido pelo Google, possui um catálogo bastante limitado, mas com excelentes opções; fácil de ser integrado à página web, bastando importar o CSS deles e usar a fonte.

	Exemplo:
	Importar no Index: 
	<link href='http://fonts.googleapis.com/css?family=PT+Sans|Bad+Script' rel='stylesheet'>

	Definir a fonte no CSS:
	body{
		font-family: 'PT Sans', sans-serif;
	}

	.painel h2{
 		font-family: 'Bad Script', sans-serif;
	}


APÊNDICE - OTIMIZAÇÕES DO FRONT-END

	Estudos de diversas empresas ao redor do mundo comprovaram que sites rápidos, além de mais prazerosos de usar, trazem mais conversões, vendas e usuários felizes.
	
	- A Amazon, por exemplo, descobriu que 100ms de melhora na velocidade de crregamento da página trazia um crescimento de 1% em seus faturamento.
	- O Yahoo! provou que cada 400ms de melhora em sua homepage provoca um aumento de 9% no tráfego de usuários. 
	- A Mozilla tornou suas páginas 2.2s mais rápidas e, com isso, causou um aumento de 15% nos downloads do Firefox. São 60 milhões de downloads a mais por ano.
	- O Google descobriu que aumentar o tempo de carregamento da página de busca de 0.4s pra 0.9s ao subir o número de resultados de 10 para 30 diminuía o tráfego para 20%
	- Até a Caelum já fez experimento em seu site. Uma página que tinha tempo de carregamento de 6s em comparação com uma de 2s causava uma perda de 18%  na taxa de conversão.

	1. OTIMIZAÇÃO É COISA DE PROGRAMADORES
	- Muitos acham que a performance de um site tem a ver com o a parte server-side (lado servidor) do projeto. Certamente um código ruim no servidor pode causar imensos gargalos de performance. Uma query mal feita, um algoritmo custoso de executar etc.

	- Na esmagadora maior parte das situações, a realidade é que o processamento server-side é responsável por pelo menos 10% do tempo total do carregamento da página. A maior parte dos gargalos de performance está em prática client-side.

HTMAL E HTTP - COMO FUNCIONA A WORLD WIDE WEB?

	- A primeir coisa que devemos levar em consideração no ciclo de comunicação entre o navegador (cliente) e o servidor, é que o cliente deve conhecer a localização da página (recurso) que ele deseja obter e exibir ao cliente.
	- O cliente deve ser informado de qual o endereço do recurso necessário em determinado momento, normalmente o usuário final provê essa informação entrando em um endereço na barra de endereço do navegador, ou clicando em um link.
	- Esse endereço é conhecido como URL (Universal Resource Locator), por exemplo:
	http://209.85.227.121:80/index.html
	
	O Endereço exemplificado é formado por 4 partes básicas:
	1. Protocolo de Comunicação a ser utilizado para obtenção do recurso. No exemplo citado, o protocolo utilizado pé o HTTP.
		- A comunicação entre um cliente (geralmente o navegador). 
		- Um servidor pode ser feito com o uso de diversos protocolos, por exemplo, o FTP (File Transfer Protocol) para a transferência de arquivos, ou o protocolo file, de leitura direta de arquivos quando desejamos obter um recurso acessível diretamente pelo computador sem utilizar uma conexão com um servidor Web.
	2. ' // ' e 3. ' / ' , são os endereços de IP do servidor (onde está hospedados os recursos que queremos) e a porta de comunicação com o servidor. 	
		- Os servidores Web utilizam a porta 80 por padrão, então no exemplo citado, poderíamos ter omitido essa informação que a comunicação seria feita com sucesso. 
		- O endereço IP é um código ocupado de 4 octetos representados em formato decimal separados por um ponto, é um número um tanto difícil de ser memorizado.
		- A próxima geração de IP, criada para evitar o fim dos endereços disponíveis é formado por 8 grupos de 4 dígitos hexadecimais separados por ":", por exemplo: 2001:0db8:85a3:1319:8a2e:0370:7344, por isso a Web utiliza servidores de nomeação de domínio (DNS - Domain Name System), para que o usuário final possa iformar um nome em vez de um número e uma porta, por exemplo: www.caelum.com.br.

	4. O caminho do recurso que desejamos obter dentro do servidor. No nosso exemplo estamos solicitando o arquivo index.html, que é o nome padrão de arquivo para a página inicial de um site, e, nesse caso, também poderia ser omitido. A doação desses valores padrões permite que para obtermos a página inicial do Site, os usuários finais digitem somente o nome do endereço: www.site.com.br na barra de endereço.
	

O CICLO HTTP
	Uma URL é um recurso usado para adicionarmos links em nossa página. Através dos links podemos ter acesso à conteúdo local ou externo. Mas o que acontece quanco clicamos em um link ou clicamos em ir logo após digitar um dendereço na barra de endereço ?
	- Essas ações disparam uma chamada, dando início ao ciclo HTTP. 
	- Essa chamada é o que chamamos de requeste, ou seja, requisição.

	A correta comunicação entre os dois lados do ciclo depende de uma série de informações. Um HTTP request leva consigo todos os dados necessários para que o lado do servidor tome a decisão correta sobre o que fazer. Existem algumas ferramentas que permitem observar quais são essas informações. 

	- O protocola HTTP pode ser utilizado por uma série de aplicações, para uma série de finalidades. Nosso foco é no uso do HTTP para páginas da web que podemos acessar de um navegador. Alguns navegadores incluem ferramentas de inspeção da página em exibição, e a maioria dessas ferramentas consegue nos mostrar o conteúdo da requisição HTTP. Uma dessas ferramantas o complemento Firebug, disponível para o navegador firefox. 

	Em alguma dessas ferramantas veremos que a primeira informação que aparece é a palavra GET. 
	- GET é um dos métodos suportados pelo http para realizar a comunicação, e ele deve ser utilizado quando queremos OBTER um recurso que o servidor tem acesso.
(ou seja, quando quisermoa visualizar as informações que o serviços de request está fazendo).
	- Caso o servidor encontre o recurso que queremos:
		- Ele retorna para o cliente um RESPONSE (resposta) contendo o recurso que desejamos.
	- Outra informação importante são:
		- os endereços do recurso que desejamos obter (HOST)
		- O tipo de recurso que o cliente espera obter (Accept) 

Essa resposta contém uma série de informações importantes para que o cliente possa tomar as decisões necessárias e, no caso de sucesso na comunicação, exibir o recurso para o usuário. 
	
	As informações mais importantes, no nosso caso, são o código de resposta e o tipo de recurso encontrado ( Content-Type ). Podemos encontrar o código 200 que indica que o recurso foi localizado com sucesso e incluído na resposta. 


PRINCÍPIOS DA PROGRAMAÇÃO DISTRIBUÍDA

	Uma página Web é uma programação distribuída. Isso significa que há uma comunicação distribuída via redes entre dois pontos. No caso, o navegador e o servidor da página.
	
	E, como toda aplicação distribuída, há alguns princípios básicos de performance. Quando há comunicação remota envolvida, geralmente queremos:

	- Diminuir o volume de dados trafegados entre as partes;
	- Diminuir o número de chamadas remotas;

FERRAMENTAS DE DIAGNÓSTICO - YSLOW E PAGESPEED

	O primeiro passo é saber o que melhorar. Há diversas boas práticas focadas na literatura de performance Web. 
	Existem ferramentas que nos auxilia no diagnóstico que analisam a página dão dicas sobre o que e como melhorar. Há até notas de 0 a 100 para você saber o quão bem está nas práticas de otimização.

	As mais famosas são:
	YSlow - feita pelo Yahoo;
	PageSpeed - feita pelo Google.

	Ambas são extensões para Firefox  e Google Chrome:

	- Há algumas regras que envolvem programação no servidor, como configurar compressão GZIP ou acertar os headers HTTP. É uma boa conversar com a equipe do projeto para também fazerem esses acertos, tais como minimificar/comprimir os códigos js e css; 

COMPRESSÃO E MINIFICAÇÃO DE CSS E JAVASCRIPT
	
	É importante fazer códigos legíveis usando identações bem espaçadas, nomes de variáveis simples, bom espaçamento visual.
	Entretanto, nada disso importa na navegablidade do Web site, pois tudo isso se torna inútil na hora da execução. 
	Muito mais que isso, todas essas práticas acrescentam bytes na hora de renderizar a página. Então por quê gastar bytes com coisas desnecessárias?

	Minificação de CSS e JavaScript nos ajuda a otimizar nosso site. 

	Como funciona? Bem, rodamos uma programa compressor nos nossos arquivos para tirar todos esses bytes desnecessários para simples execução. O resultado são arquivos CSS e JavaScript idênticos em funcionalidades mas sem bytes de comentários, identações e etc. Até variáveis longas são reescritas com nomes mais curtos tipo 'a', 'b' etc.

	A boa prática continua sendo escrever códigos bem legíveis e bem documentados. 

	1. YUI Compressor
	Compressor do Yahoo - comprime tanto código CSS como JavaScript
	http://developer.yahoo.com/yui/compressor/

	- YUI é uma ferramenta de linha de comando. Podemos salvá-lo no local desejado, em seguida rodar o seguinte comando especificando o arquivo que desejamos comprimir:
	java -jar yuicompressor-x.y.z.jar script.js -o script-min.js
	ou:
	.\yuicompressor-x.y.z.jar script.js -o script-min.js

	Também existe uma solução online: https://refresh-sf.com/

	1. COMPRESSÃO DE IMAGENS
	Imagens também são fortes candidatas a otimização. 
	
	O HTTPArchive.org armazena informações históricas coletasdas mensalmente sobre os 17 mil sites mais acessados da Internet Mundial. Com base nelas, compila alguns dados e gráficos interessantes.
	
	E, com relação à imagens, os estudos comprovam que 60% do peso de uma página está nelas:

	Average Bytes per Page by Content Type
	Scripts - 152kB
	Stylesheets - 30kB
	Flash - 86kB
	Other - 31kB
	HTML - 37kB
	Imagens - 494kB
	
	Total - 830kB
	
	Se conseguirmos otimizar as imagens o resultado final será de grande impacto.

	2. OTIMIZAÇÃO LOSSY
	- Esse termo está relacionado à perca de qualidade. Quando salvamos imagens em jpg, podemos escolher o grau de compressão, obtendo imagens menores mas sacrificando a qualidade.
	
	- Devemos observar até que ponto esse tipo de compressão pode prejudicar a nossa imagm, levando em consideração que muitos desses efeitos causados passa despercebido ao olho nu e menos analítico dos usuários Web.
	
	- Podemos fazer essas alterações em nosso editor preferido, manualmente. Ou podemos usar serviços web de ótima qualidade, como o JPEGMini.
	Eles usam um algoritmo que promete simular as características de percepção do olho humano, o que nos permite "piorar" a qualidade da imagem apenas em pontos que são poucos percebidos pelo nosso olhar.

	http://www.jpegmini.com/

	
	3. DESIGN OTIMIZADO
	- Com o poder do CSS3 em diante, muitos recursos que, antes só podia ser feito através de imagens, hoje podemos substituir por comandos CSS.
	- Isso nos ajuda e otimizar bastante nosso site.

	4. OTIMIZAÇÃO LOSSLESS 
	- A otimização mais simples e eficaz com imagens é chamamos de compressão 'lossless'. É diminuir o tamanho da imagem sem perder absolutamente nada na qualidade da imagem.
	- Isso é possível porque os formatos de imagens (JPEG, GIF e PNG) em geral guardam em seus arquivos mais informações do que o necessário para renderizar uma imagem. Por exemplo, diversos metadados são imbutudos nas imagens quando a salvamos, como, por exempo, data e hora, localização, coordenadas de GPS em casos de algumas câmeras, ou em outros casos como na exportação de imagens pelo Photoshop levam bastantes metadados e incluindo alguma miniatura da imagem embutida no mesmo arquivo.
	- Ferramentas para esse tipo de otimização: Smush.it
	http://smush.it/
	- Ou podemos usar um programa desktop muito bom: https://riot-optimizer.com/

	5. DIMINUIR NÚMERO DE REQUEST
	- Até o momento usamos práticas para diminuir o tamanho das requisições e o volume de tráfego de dados. 
	- Devemos levar em consideração, também, a redução de número total de request.
	- No próprio console do navegador, ao pressionar F12 e clicar na aba Network, ou usando o YSlow, podemos visualizar todos os arquivos na requisição do nosso site: CSS, JavaScript, Imagens, Flash etc, requisições feitas ao servidor. Isso sem contar com o próprio HTML da página e em possíveis Request extras numa aplicação como Ajax.
	- Cada requisição envolve uma chamada para o servidor o que gera um OVERHEAD bastante grande. A maior parte do tempo de um request é gasto em tarefas de rede (DNS, SSL, TCP/IP). 
	- Quando otimizamo os requests podemos notar que apenas uma pequena parte é gasta cmo download dos bytes.
	- Fora o gragalo da própria rede, existe uma limitação no número de requisições que um navegador faz simultaneamente a um mesmo servidor. Esse número varia e pode ser baixo em alguns servidores antigos (apenas 2 conexões). Nos navegadores mais modernos, gira em torno de 6 a 8 conexões. Parece um número alto - e realmente foi uma grande evolução -, mas se você começar a contar todos os arquivos externos que está usando, verá que há chances de uma página mediana fazer dezenas de requisições (requests).
	 
	- O HTTPArquive reporta uma média de mais de 80 requests (em kB) sendo feitos na págin, ou seja, mesmo com 8 conexões simultâneas, o volume de requests é bem maior, o que vai atrasar o carregamento total da página. Em casos (como arquivos JS), o navegador fica travado até que todos os downloads terminem. 

	Diminuir o número de requisição é essencial!

	6. JUNTAR ARQUIVOS JS E CSS

	No caso de arquivos JS e CSS o bom é juntar diversos arquivos em um único número menor para minimizar as requisições.
	- Se vamos usar um JQuery com 3 plugins e mais 2 arquivos de aplicação, poderíamos juntar todos em um ou 2 arquivos. 
	- O Ideal é continuar usando as boas práticas de programação em arquivos separados, mas antes de hospedarmos podemos usar algumas ferramentas com recursos que juntam esses arquivos em um só. 
	- O próprio JQeury faz isso. Se olharmos o arquivo jquery.js veremos que é um arquivo que juntou os outros 22 arquivos separados, que foram criados de maneira independente para melhor organizar e encapsular as funcionalidades do projeto.
	- A mesa coisa vale para o CSS - Podemos criar arquivos com tipografia, outro com estrutura de layout e outro com estilos visuais, porém, na hora de subir a aplicação no ar, a boa prática é diminuir o número de arquivos e juntar quantos puder.


IMAGEG SPRITES
	É uma técnica utilizada para juntar imagens que consiste em criar um arquivo só e posicionar diversas imagens dentro. Depois, usando o CSS, "recorta-se" as partes da imagem que queremos em cada parte da página.
	- O Google, por exemplo, usa essa técnia. Em sua home, existe um único arquivo de imagem com várias imagens em si e com css é definido a parte da imagem que desejam exibir na home page.
	- A técnia é trabalhosa, pois inicia-se criando uma imagem só, depois precisaremos tomar nota dos tamanhos de cada imagem e das posições X e Y de cada uma delas.
	- Utilizamos a propriedade background do CSS do elemento como na tácnica Image Replacement, mas precisamos especificar a posição da imagem em relação ao ponto inicial do elemento.
	- Podemos ir em busca de ferramentas que nos auxiliam na criação desses arquivos.


DATA URI
	Pensando em diminuir mais o número de requisições para imagens, podemos utilizar uma técnica conhecida como Data URI. A ideia é embutir conteúdos binários (como imagens) dentro dos arquivos de textos (como HTML ou CSS). Basta converter os bytes da imagem em uma string comum que segue o formato de codificação chamado Base 64. 
	- Esse processo de conversão é feito por algum programa que converta para a base64 ou diretamente no servidor por meio de código Java, PHP etc. 
	- Há alguns servisos online que ajudam nessa tarefa.
Exemplo:
	Normalmente: 

<img src="\img\figura.jpg">

	Usando Data URI:

<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKEAAAAyCAQAAACeqnPQAAA
JAUlEQVRo3u3baZBVxRXA8d8wbAO4oiKKC4pGo7hQYpByCcYF3LXigiAhBgWNWmiMUVFBQEstU4UEIz
GKC6jjluAeDaWJo5aCREARcIuAiCiMghGBYTj58C6P++C9YWAWBDn3w3u3u2/f7v/te/qc032hicEmq
xC1fFSYbLAmNnlpYmKtw0sfEzd9iINrB1XzOD5uibdieayU72N07BnC4Gq1o73rParMx2Z5we16O0Tj
WuxnS93d6sC6QDi5pvCOiKHxeiyLfDI6hMlraUGJa32Ut+5P9VBUS/08Rwhd6wJhjg5svU7wWsRF8V5
UJd9ndGJV0svsVJ2V5vl8NUVw9A8dYaq5e8eYauP7SQyPhbF2EaIKPTwmW2OZ/tppmLx0XfT3mBVJ3i
UbBcLd4rV4P5bEa3HdWvEdGi/FiqieVIGwpdeSGhc4K2+JTt4RvtVqIxmF/SIiYnY0rBLf1nFXVEb1p
SDCYuOSOp/TumDril3myo3kRa7eKOwZ82LdpCDCm5M6f6t+5IegC/eJl2PdpQDCjomeu49NCmFVM/Kl
sTSi9hD+QwhzbL3JIcx/FMfwWF/Ji7BzUvPJ/CgQtohnI2oX4V1CeJIfBcI2MSmithFmjOkLfhQIO8S
ciNpGuH9S+yE/AoTtY1FE7SM8JQmFNdnkEbaKmRF1gfBCIUxZz/YeZpC73Ki7HfLml+isvxF+7ySNqk
BY4md2Xu3atg5Pne3scOzlEnc4x1bZ6452o5udkTijhRGWxFsRdYPwGiE8sZ4In8u2cYGzV8srdoNlq
V7M1KcAwp9bLpyWc/VE4c3s2ShhqkGWJnWV64COyrO1T9K+CoRF8XhEXSHsJ4R31gtgkX8b540kvrRU
21TebonPvcIM48xM+nJHEi7LRdhVrIFweg7C0jWolOtrYU7KLNsWRHhzRN0hPFUIy2oUUN3SQCHclk1
pYqpQ6U7bJSnHmiWEq2uAcIVb7KyNodmo0UeOtqWjTBXC8AIIe0fUJcIDk/scXCMd3szXwuPZ85uFyp
SuK9Ldf4Xwne3XG+Ffsuejkwe/d1ZvLhMm5EW4eyyuW4RFvhDC+esBbjeXeshwPTTylPBKkr6X5cI12
XJHmZD053kH1GAU7pc97yaEZ1Lly4QleRGOjahbhNwrhIfWGeB5FmXb+R/vCP9KcvoIFZqBfT2dlBmv
S4HppHoIK1PKZh8h3J4q//DKvq0G8ISIukd4THK3dQvpn5FV4h9m27sS4UhhPFoZabkQPnRWzrrL+iB
cksrdXQiDUin350XYND6qD4S8KoRPNK82wK18LsxNLLd9vZ+D8FXhJTf4VgjzXJxjE9YnwoER9YPwiO
SOw6qN8HQh9Mue/zwH4X3ZPnxroBZ5rq8fhG3j+/pCyPBkxe6X1UQ4RFhim9Sk9GkK4cXJfDmigM9SH
YTzawHhoxH1h7CRN5L7PpB1nvLJKQaCW4XFtkzlfJRCmDGUXl3j9S2E8Egh3JLK30PUGOGOUVGfCGlt
UnLv2Y7NW6KDV4TQBWcKkXLYDs95kVfO8mNWW7pvrkFehFtZIcxKlX6kFhBeE1G/CGmRNT/CM3pn/Yo
SHV2gNOsRPIotzBU+S7Z07JrgX4Vwa3MS37tbYoq0NMBX9s+LMKP5wjAt0DYxUGqGsCg+qX+ENHCZ+S
llstAM0xKzJJJZu3syVnomLtcUE1QIK3IQcmjijYSFXk6cu9C7AMKuKhNt/LUQlptXQ4THRWwIhJnxc
5t5eX31+S7P8aT7WJLNm+Ci1RCyRdKtVdtLntGhAEIuTkygTNTnGGNriPCJDYcwMxqP8EcvetcCC73h
bpfqYos1yu2tv8fd7dcaa+v0PPPvns41zLNGuMSuqfR9dbffqhgfaOVapR7UR2uc5DjbZ/NOcKJdcuz
S3+ioJJVyvJMyd6jDqWQdEG7UkqwSx2aENUNYuhlhTRHO3oywZgh3iahvhP2zR6cqW3dIjfYWbuvqTGi
+FqSxgxXbI98utBDn1D/CUKZUqdK1+Mhne74G3d5H2KeWEL7pJXNM1yYvwuEbAuFpa6Q1zf4ryrtdqTj
HJGmWd6RUhbBpKqco50xOTrqWFkm5Btoq1iyV11hxCuHbGxphmUHeV+Fvyciba7xJ2qCXMnTwmSt8rVx
PcIDplvhstYX1O80zLWdUr0Q4wIOesswMuyVqZIHFXrGjYtOcAAa4H0PM9aV7NEaxMcr9z1VglHnmJMt
dDY2x0HdGZsIaoc5swioR3pvowm0w3ccOtJ/lOmtisb64yvXoZzo6CaNsY6gPwFRDNXeTuakwwXne1Ng
RylPRnJUIb1HpLC1NNATtLXKUnbxqGO5zN5joV3b1thIlvtINV3hNc+0st6dOXtDQDiochN+ZpK1Dzc8
MhBCxIRC+ZayxxtoZ010OPtADE43IBq1WIdwGnVXIuFrbo3XOKuCj7neYQyzVOQ/CF8Fwo3GlceBSM9D
NHOxgSVZ5/MIyvTEuaVUnLZOXuUfiIo5zHXgqs8K3oRCmX+TpSTR6ur7YV6m5HvHTHIRNk98mzrUguW6
BXtk6pvg0eSj5EI4Fw/wdj7sTmRWcxhopd7Ceydrchd4zyhf64hPdU238g2lGWOxUfOtMcJM3fngI+2X
V+LPmKMqDsKnjhO3QQqXjsnWUGgIOTUW210Q4Fn/1T3C+8kTLXe9hvXC27+yNmfphYrKo2sfu+vvKjhp
Y4jR8YgB4MKO9K9RBuH+lFPx0J1zuIAc5SOvVEDY0y2G43sd5R2FT21roVi0MsSg1c/czwdZ2tzi12Sg
/wh4WOdYuyjwGunrbXFvhahPQUbgIVxpvR0daaid/9iROSx79KFPspbO5+sJkMbrOEBb8gOxrC8z3pXk
GoCx5ITO/p3jdDO9on5qRv9Ak9Xuybyz1jdNzDJonlfvYOam0dr7QDgOSbfGD3YcG/qTSUm8nkZxGPkj	
WtNuZapqnXWO8EiVGKleuHzr60LtGu82LaKXMMpUeyOjswWLPGF0HI3EdP2PMlbXtPSzWZpVdltfyq1q
aF/wcqGXqfyNPprynXD9nu1WhuM0f0xaWZrr6vjoPZvMn3YXkRPe4bG2F/g9S7CNMkQtgRwAAAABJRU5
ErkJggg==">

	- Nem todos os navegadores suportam essa técnica, além disso, usá-la, exige um pouco de conhecimento de programação no servidor.

Estudar mais sobre, no Blog: https://blog.caelum.com.br/por-uma-web-mais-rapida-26-tecnicas-de-otimizacao-de-sites/

APÊNDICE - LESS
	Less é uma linguagem de programação baseada em CSS (mesma ideia, sintaxe familiar) com recursos que fazem falta no CSS em algumas sistuações.
	- É também conhecido como pré-processador, pois na verdade, é usado para gerar um arquivo CSS no final.
	- Alguns dos recursos apresentados pela linguagem é o uso de variáveis, suporte a operações matemáticas, sintaxe mais compacta para representar hierarquias e mixins.

	1. VARIÁVEIS
	Podemos usar uma variável para definir uma cor padrão, por exemplo, para a aplicarmos em qualquer componente da nossa página. É aí que o CSS deixa a desejar, pois ele não possui suporte para criarmos variáveis, o LESS sim!

	Exemplo:

	@corprincipal: #BADA55;

	#titulo{
		font-size: 2em;
		color: @corprincipal;
	}

	button{
		background-color: @corprincipal;
		color: white;
	}

	Repare que no @corprincipal que não é CSS puro, mas tem uma sintaxe muito parecida. Depois de compilado, o LESS vira esse CSS.

	#titulo{
		font-size: 2em;
		color: #BADA55;
	}
	
	button{
		background-color: #BADA55;
		color: white;
	}

	2. CONTAS

	Sabe quando você tem aquele elemento principal com 960px mas que precisa de um padding de 35px e duas colunas lá dentro de tamanhos iguais mas deixando 20px entre elas? Qual seria o tamanho de cada coluna mesmo? 435px. Aí você coloca no CSS:

	.container{
		padding: 35px;
		width: 960px;
	}

	.colunas{
		width: 435px;
	}

	E quando alguém mudar o tamanho do padding, você torce pra lembrarem de refazer a conta da coluna - que, aliás, seria (960px - 35px * 2px - 20px) / 2px = 435px. No LESS poderíamos fazer a conta direto na propriedade e o resultado final é calculado:

	.coluna{
		width: (960px - 35px * 2px - 20px) / 2px;
	} 
	
	Melhor ainda, junte com as variáveis que vimos antes e você nem copia e cola valores!

	@total: 960px;
	@respiro: 35px;
	@espacamento: 20px;

	.container{
		padding: @respiro;
		width: @total;
	} 	
	
	.coluna{
		width: (@total - @respito * 2 - @espacamento) / 2;
	}

	E dá pra fazer contas até de cores!

	3. HIERARQUIA
	Você tem um #topo com um título h1 dentro de uma lista li de links. E quer estilizar todos esses elementos. Algo assim:

	#topo {
		width: 100%;
	}
	#topo h1{
		font-size: 2em;
	}
	#topo ul{
		margin-left: 10px;
	}
	
	E se precisarmos mexe no id topo? Ou trocar para header Semântico? Teríamos que alterar em três lugares, e também contar que ninguém tenha usado em outro canto. Sem contar que essas três regras não precisam estar necessariamente agrupadas no arquivo e podiam estar em outro arquivo qualquer. 

	No LESS podemos escrever regras de maneira hierárquica, uma dentro da outra, e ele gera os seletores de parent. O mesmo CSS anterior podia ser escrito no LESS.

	#topo{
		width: 100%;
		
		h1{
			font-size: 10px;
		}

		ul{
			margin-left: 10px;
		}
	}

	Podemos usar vários níveis de hierarquia (sem abuso!), deixando o código mais estruturado, flexível e legível.

	4. FUNÇÕES DE CORES E PALHETAS AUTOMÁTICAS 

	Muito útil para aplicação de cores secundárias, tipo aquelas cores que usam no fundo e no primeiro plano a mesma cor só que com nuance mais clara ou mais escura. Geralmente pegamos o código de cada cor ou jogamos no Photoshop, e tal... Bom, e se precisarmos mudar a cor, deve gerar as outras secundárias, certo? Com o LESS, podemos usar funções para gerar essas cores:

	@corbase: #BADA55;

	body{
		background: lighten(corbase, 20%);
	}

	h1{
		color: @corbase;
	}

	button{
		background: saturate(@corbase, 10%);
	}

	- Vai gerar cores 20% mais lights e 10% mais saturadas:

	body {
		background:#dceca9;
	}
	h1 {
		color:#bada55;
	}

	button{
		background:#bfe44b;
	}

	Ainda temos: darken, desaturate, fadein, fadeout, spin, mix e até funções matemáticas como round.

	5. REAPROVEITANDO COM MIXINS
	É de grande utilidade o LESS pela sua capacitade de criar suas próprias funções, que ele chama de MIXINS. É útil quando temos que repetir a mesma coisa várias vezes, comos as propriedades do CSS que precisam de prefixos, tipo uma borda redonda:

	Podemos definir um mixin recebendo como argumento o tamanho da borda e distribuindo as versões pros diversos navegadores:

	.arredonda(@raio: 5px){
		-webkit-border-radius: @raio;
		   -moz-border-radius: @raio;
			border-radius: @raio;
	}
	
	Parece uma classe CSS mas ele recebe uma variável como parâmetro (que pode ter um valor default também). E você pode usar esse mixin facilmente:

	.painel	{
		.arredonda(10px);
	}
	
	.container {
		.arredonda;
		width: 345px;
	}

	Isso gera o CSS:

	.painel{
		-webkit-border-radius:10px;
		-moz-border-radius:10px;
		border-radius:10px;
	}

	.container{
		-webkit-border-radius:5px;	
		-moz-border-radius:5px;
		border-radius:5px;
		width:345px;
	}

	Muito útil e, com infinitas possibilidades, podemos criar default para botões, cores, cores gradientes etc.

	6. EXECUTANDO O LESS

	- No site LESS, podemos baixar a versão standalone dele. (http://lesscss.loopinfinito.com.br/). ou http://lesscss.org/
	- Podemos rodá-lo apenas rodando um JavaScript na página que faz o parsing (análise) dos arquivos .less quando ela carrega.
	
	<script	src="less.js" type="text/javascript"></script>
	
	- Com isso, podemos incluir diretamente o nosso arquivo .less usando uma tag <link> , colocada antes da tag que carrega o less .js :

	<link rel="stylesheet/less" type="text/css" href="styles.less" />

	Para melhorar a performance, o ideal seria gerar o CSS antes usando o compilador. Há uma versão em linha de comando usando o Node.JS, mas como é JavaScript, você pode rodá-lo em qualquer canto - até no Java com Rhino.

	- Há também programas visuais para instalar, como o LESS.app e dá para testar código rapidamente online mesmo no LessTester.com	
	
	- No Windows também podemos usar o https://www.winless.org/ , que é fácil de usar.

	- Também podemos usar uma versão Javascript do LESS, que transforma nosso código em CSS dentro do navegador.

	- Com Less podemos fazer mixins mais complexos e, até mesmo, fazer uso de estrutura if, else.
	
	7. OUTROS PRÉ-PROCESSADORES CSS
	
	- Sass: https://sass-lang.com/ - muito usado e conhecido no mundo Ruby e é recheado de funções, fazendo com que ele se torne mais poderoso que o Less e mais complexo.
	- Stylus: https://stylus-lang.com/ - A vantagem é que simplifica mais as sintazxe
	
	DICA: Para criar background/cores gradiente: https://www.colorzilla.com/gradient-editor/


	SAINDA DAS LIMITAÇÕES DE HTML 
	- O navegador não executa qualquer tipo de código. Existem códigos que vai além de HTML, CSS e JavaScript. Em projetos mais robustos, ou mais dinâmicos deve-se envolver-se com uma linguagem mais robusta e complexa, que também envolve INSFRAESTRUTURA NO SERVIDOR.

	1. Linguagens: Há diversas linguagens a serem usadas, tais como: PHP, Java, Ruby, Python, C#;
	2. Servidores: Apache, Tomcat, JBoss, IIS, nginx e outros.

	Linguagem no servidor é usada para: gerar páginas dinamicamente com dados de banco de dados da aplicação, enviar e-mails de usuários, processar tarefas complexas, validação de segurança garantida, e outras coisas mais.

	COMO FUNCIONA UM SERVIDOR HTTP

	Se escrevermos um código HTML simples e salvar o arquivo como .html, basta abri-lo no navegador e logo veremos o resultado do código na página. 
	O Protocolo HTTP é útil para servir páginas na Web. Motivo pelo qual os endereços na web começam com HTTTP://. 
	Quando acessamos uma página na Web, dizemos que estamos solicitando uma Requisição no Servidor. Ou seja, pedimos que certo conteúdo seja exibido.

	Por exemplo: 
		Ao acessar: http://www.site.com.br/pagina_x
		- Estamos conectando via HTTP ao servidor www.site.com.br
		- Requisitando a URL /pagina_x
		- Do outro lado há um servidor HTTP esperando novas requisições que é responsável por servir o que o usuário está pedindo.
		- Esse servidor é um programa que instalamos e é o responsável por processar as requisições.
		- A grande questão é que esse servidor não precisa ser igual ao navegador, lê um código e envia o seu conteúdo para o cliente. 
		- O servidor pode executar código e gerar HTML na hora pro cliente, dinâmicamente. E é esse processamento de lógica dinâmica que faremos como o PHP.

	COMO FUNCIONA O PHP NO SERVIDOR
	
	Existem diversos servidores compatíveis com o PHP. O mais conhecido de todos é o Apache.
	À partir do PHP 5.4, ele já vem com o servidor imbutido. Ideal para testes e desenvolvimento.
	
	- Ao entrar na pasta do projeto, digite no terminal: php -S localhost:8080 (-S indica que queremos o servidor imbutido nele)
	- Depois basta digitar http://localhost:8080/ no navegador, e esperar o servidor responder.

	Mas não precisa ser assim pra executar código PHP do lado servidor. Basta renomear o arquivo, por exemplo, index.html para index.php. Com isso, podemos misturar código PHP com HTML.
	
	Código PHP:

	<?php 
		//Código PHP
	?>

	Código PHP e HTML:

	<h1>TITULO</h1>
	<?php 
		//Código PHP
	?>
	<p>Parágrafo</p>
		
	PHP - DATAS
	https://www.php.net/manual/en/function.date.php
	
	REAPROVEITAMENTO DE CÓDIGO COM INCLUDE

	Com HTML, a única solução é ficar copiando o código, com o PHP, podemos tornar o cabeçalhos e rodapés da página padrões reaproveitando com Include.

	<?php include("arquivo.ext") ?>

	SUBMISSÃO DO FORMULÁRIO

	- Todo formulário criado em HTML tem seus dados enviados para o servidor quando submetidos. Cada campo do formuláro é enviado como parâmetro na requisiçao feita ao servidor.

	- No formulário, podemos indicar que página (URL) irá receber esses dados, através do atributo 'action'.

	- Também podemos indicar a maneira como os dados serão enviados, através do atributo 'Method' que pode ser definico como 'POST' ou 'GET'. Ambos os métodos enviam os dados ao servidor, mas o GET faz isso via parâmtro na URL enquanto o POST enviam os dados no corpo da requisição (e, portanto, não é visível na barra de endereços).
	
	<form action="pagina.php" method="POST">

	PARÂMETROS COM PHP

	- Os dados enviados no formulário são recebidos no PHP e podemos ter acesso a eles através do próprio PHP, usando $_GET e $_POST, dependendo de qual desses métodos foi usado no form.
	- Para usar os valores, precisamos apenas saber o nome do componente HTML que foi criado: <input type="test" name="nome">
	- No PHP, podemos acessar cada parâmetro individualmente usando uma sintaxe de arrays: <?php  $_GET['name']; ?> ou $_POST['name']
	
	LISTA DE DEFINIÇÕES HTML

	- <ul> - trabalha com lista ordenadas - seguidas de <li>
	- <ol> - trabalha com lista não ordenadas - seguidas de <li>
	- <dl> - trabalha com lista de definições. Semanticamente, serve para criar lista de termos e suas respectivas definições - seguida de <dt> e <dd>

	Exemplo:
	<dl>
		<dt>Cursos</dt>
		<dd>Curso 1</dd>
		<dd>Curso 2</dd>
	</dl>

	APÊNDICE - PHP: BANCO DE DADOS E SQL
	
	- Na maioria dos sistemas Web, os dados de negócio ficam separados em um banco de dados ao inves de ficar escrito diretamente no HTML. 
	- No caso de uma loja virtual, os produtos seriam cadastrados nesse banco de dados externo e depois seus dados seriam exibidas na página .php .	
	- Um banco de dados é parecido com uma planilha do Excel. Dentro dele temos várias tabelas separas por colunas e linha, e pode haver relacionamento entre elas.
	- Para fazer uso, ou manipular os dados das tabelas de um BD, fazemos uso de uma linguagem separada conhecida como SQL. 
	- SQL permite que façamos buscas nas tabelas por certos tipos de dados  e que possamos inserir, remover dados e atualizar dados.

	MYSQL E PHPMYADMIN

	- Bancos que aceitam comandos SQL: MySQL, Oracle, SQL Server, DB2, Postgre, SQLite. 
	- Aqui usaremos MySQL
	- Produtos com interface gráfica que ajuda na configuração: Workbench e o PHPMyAdmin.
	- PhpMyAdmin é um administrador de MySQL escrito em PHP para Web, roda em servidor normal e pode ser acessado através do navegador.
	
	CONEXÃO COM BD
	- $conexao = mysqli_connect("localhost", "root", "", "senha");
	
	BUSCA 
	- $dados = mysqli_query($conexao, "SELECT * FROM produtos);

	DADOS NO PHP
	- Transformar dados da tabela em algo usável no PHP:
	$produto = mysqli_fetch_array($dados);
	
	- A variável $produto é um array com os dados do primeiro produto da busca indexados pelo nome das colunas no banco de dados. Com isso, podemos acessar, por exemplo, o preço do produto fazendo: $produto['preco'] e assim por diante para cada coluna.

	BUSCA DE MUITOS RESULTADOS
	- Fazer um Select que busque todos os dados da tabela, pode ser custoso. Iamginem uma consulta pra listar milhares de registros da tabela? Podemos limitar a consulta da seguinte forma:
	SELECT * FROM produtos LIMIT 0, 10
	- Queremos 10 resultados contando à partir do primeiro (0).
	- Podemos trocar o primeiro número para acessar informações em outras partes do banco.

	ORDENAÇÃO DOS RESULTADOS
	SELECT * FROM produtos ORDER BY nome
	- Definir a ordem (ASC - Ascendente ou DESC - Decrescente).
	SELECT * FROM produtos ORDER BY data DESC 
	
	LIMIT - 0 indica offset, ou seja, a partir de qual item queremos.
		3,6 indica que queremos os itens do terceiro ao nono.			

	
	APÊNDICE - SUBINDO APLICAÇÃO NA NUVEM

	- Existem diveros provedores com suporte a PHP e MySQL.
	- Levar em consideração: preço, qualidade do serviço, suporte e reputação da empresa.
	- Serviços que devemos escolher, entre duas opções, de várias:
		1 Planos Clássicos: 
			- Paga um valor fixo por mês e tem direito de usar uma máquina compartilhada com usuários. 
			- Costumam ter um valor mais baixo, mas limitações técnicas em casos de site que tenham um pouc mais de usuários.
		2. Plano Cloud Computing: 
			- Não tem restrições técnicas com relação a volume de acesso.
			- A aplicação pode começar pequena e crescer indefinidamente, sem problemas, em um ambiente escalável que cresce elasticamente conforme suas necessidades.
			- Nesse cenário, paga-se por quanto usar dos recursos em cada mês, e não uma mensalidade fixa. 
			- Costuma ter valor mais alto que hospedagens clássicas, mas traz um ambiente bem mais robusto.

	
	JELASTIC CLOUD LOCALWEB

	- Permite subir uma máquina com PHP e MySql em instantes, e enviar ZIP com o nosso projeto para ser executado.
	

	APÊNDICE - MAIS INTEGRAÇÕES COM O SERVIÇOS WEB

		
	
	