1- HTML

1. Baixar o xampp e configurar os arquivos: hosts, httpd-vhosts.conf
2. Testar um arquivo com texto puro e explanar a questão de interpretação do navegador à textos com e sem acento.
3. Denotar textos marcação que formatem o texto, assim mostrando marcadores que influenciam a maneira com que cada texto será exibido (html, head, title, meta charset=utf-8, body, h1, h2, ul, li).
4. Esplanar sobre o uso dessas marcaçoes mostrando o termo usado definitivamente durante o curso: tags.
5. Mostrar aos alunos que a ineficiência de estética das marcações html (tags) é onde encontra-se o seu primeiro desafio como programador frontend.
6. Esplanar um pequeno resumo da origem do HTML e a necessidade de usá-la nos dias atuais para desenvolvimento web.
7. Esplanar o conceito usual de cada tag e do conjunto de tags que forma o HTML, sintaxe e:
8. Denotar o uso de cada tag usada no primeiro exemplo.
9. Mostrar aos alunos tags que podem receber atributos, e nem todas possuem uma tag de fechamento, exemplificando com o uso da tag <img src="c:\site\index.html"> por não ter conteúdo por si só.
10. Notar as tags de estrutura do HTML: <html>, <head>, <body>, e a instrução <!DOCTYPE>, esclarecendo a declaração hierarquica das tags pais e filhos.
11. Declaração da instrução especial <!DOCTYPE html>, que não se trata de uma tag. Apresentar a sua função e mostrar aos alunos que existiam comando antigos e complexo, mas que hoje faz-se uso apenas dessa declaração simples.
12. Explanar aos alunos que o HTML5 possui diversas tags novas e apresentar as tags de: títulos, parágrafos e ênfase:
<h1> ~ <h6> - heading - segundo as ordens de importância. 
13. Explanar uma breve explicação sobre a importância dessas tags heading, levando em consideração a ordem e relevância de seu uso nos sites de pesquisas como google, yahoo, etc..., e o uso das mesmas em navegadores especiais para acessibilidad e facilidade de usuários, diferenciando seus conteúdos.
14. Exemplificar uso de Tags de para parágrafos <p>
15. Apresentar tags de ênfase: <strong>, <em>, <b>, <i>, <small>
16. Explanar o uso da tag <img> e seus atributos: src, alt.
17. Exemplificar usos das tags adjacentes da tag <img>, tais como: <figure>: usada igual a tag <img>, mas permitindo usar a tag auxiliar: <figcaption>, onde acopla-se uma legenda à imagem.
18. Explicar sobre a estrutura e que não há nenhum rigor técnico que defina o uso de uma melhor organização do projeto, mas geralmente adaptaremos de maneira que fique melhor para o nosso entendimento.
19. Prepara a estrutura de diretórios para organizar o projeto em: css, img e js
20. Breve conceito de IDES (IntegratedDevelopment Environment). IDEs com realce de sintaxe: gedit, sublime, atom, notepad++; E os IDEs com  autocompletar e visualização como o Exlipse e o Visual Studio.

Exercício de HTML

2 - CSS

1. Após o exercício, declarar alguns exemplos de Estilização no próprio HTML para que os alunos possam entender com mais clareza como eram estilizados os textos no passado, mostrando a eles que no lugar dessa metodologia surgiu o CSS.
2. Em seguida entrar no conceito de que o efeito da folha de estilo é agregado ao HTML por arquivos separados ou no próprio código HTML.
3. Sintaxe (atributos e valores) e Inclusão de CSS: {color: blue; background: yellow} 
4. Exemplificar com as duas maneiras (no próprio código e com css e com a tag style).
5. Exemplificar o uso de CSS com arquivo externo (<link	rel="stylesheet" href="estilos.css">) com a chamada dentro do HEAD
6. Conceito tipográficos - criar exemplo de formatação para paragrafos, títulos:
 - Usar como exemplo de família de fontes: fontes serifadas (serif: Times New Roman), fontes sem serifas (sans-serif: Arial, Arial Black), e fontes monospace (Fontes com curvas mais delicadas: Courier)
 - Usar um tipo de fonte padrão para todo o documento HTML, acplicando um estilo de fonte no body{font-family: "Arial",	"Helvetica", sans-serif;}
7. Exemplificar o uso de estilos de fonte com a propriedade font-style: (normal, italic, oblique)
8. Trabalhar com o conceito de alinhamento e decoração de texto, exemplificando com os seguintes atributos e valores:
 - text-align: right / center / left / jutify;
 - Definir uma série de espaçamento de texto, como a seguir:
p{
 line-height: 3px;	/*	tamanho	da	altura	de	cada	linha	*/
 letter-spacing: 3px;	/*	tamanho	do	espaço	entre	cada	letra	*/
 word-spacing: 5px;	/*	tamanho	do	espaço	entre	cada	palavra	*/
 text-indent: 30px;	/*	tamanho	da	margem	da	primeira	linha	do	texto	*/
}
9. Fazer uso de imagens de fundo, com exemplos claros de uso da sintaxe:
h1{
 background-image: url(sobre-background.jpg);
}

10. Uso de bordas, exemplificando aplicação na página, mostrando as duas sintaxes do atributo, incluíndo o uso do border-style: none, e também fazer testes como os valores do atributo style: dashed, dotted, double, groove;
Exemplo:
body{
 border-color:	red;
 border-style:	solid;
 border-width: 1px;
}

ou 

body{
 border: 1px	solid	red;
}

Exercício de CSS

CSS - Parte 2

1. Definição de uso RGB, mostrar aos alunos o conceito de formação de cores RGB - forma mais 16 milhões de cores com a combinação de três cores bases: Red, Green e Blue, variando a intensidade de cada uma de suas cores entre 0 e 255. - Fazer uso de uma aplicação que facilite a descoberta ou formação das cores.
2. Exemplificar diversos usos de cores com os atributos color, background e border-color: yellow; rgb(255, 200, 0); 
- Mostrar que esses modos não é o mais comum por questão de incompatibilidade de navegadores;
- Fazer uso da notação hexadecimal: #F2EDED (suporte universal aos navegadores) 
- Mostrar aos alunos os dois canais que representam cada cor (RGB) nessa notação;
- Aplicar a teoria da formação de base hexadecimal (0 à 15 - decimal, sendo valores hexadecimal 0-9 e A-F);
- Exemplificar a simplificação de caracteres repetidos em hexadecimal. Exemplo: #EEFF66. Ficaria: #EF6;

Outros assuntos HTML e CSS para praticar:
1. Listas: 
	- Não ordenada: <ul><li>Item</li></ul>
	- Ordenada: <ol><li>Item</li></ol>
	- Lista de definição: <dl><dt>Titulo</dt><dd>paragrafo</dd><dt>Titulo 2</dt><dd>Parágrafo 2</dd></dl>
2. Espaçamento, Margens e Dimensões:
	- padding: para espaçamento interno; 
		- Subpropriedades: padding-top
				   padding-right
				   padding-bottom
                                   padding-left
		- shorthand property: mostrar o sentido horário em que se faz a leitura para a definição das 		subpropriedades
Exemplificar como:
p{
 padding: 10px; //valor aplicado a todas as direções
}

p{
 padding: 10px 15px; //padding-top e padding-bottom
}

p{
 padding: 10px 20px 15px; //padding-top, padding-right e padding-left, padding-bottom
}

p{
 padding: 10px 20px 15px 5px; //padding-top, padding-right, padding-bottom, padding-left
}

	- margin: para margens; - mostrar uso das propriedade e 'shorthand property' da mesma forma como do padding, e exemplificar que a diferença está em um limite de espaços além do elemento, ou seja, fora de seus limites, externamente.
p{
 margin: 0 auto; //margin-top e margin-bottom = 0; margin-right e margin-left = auto;
}

	- height e width: para dimensões - Exemplificar conforme o código abaixo:
p{
 background-color: red;
 height: 300px;
 width: 300px;
}

3. Links HTML - Exemplificar com exercícios propostos links (âncoras) redirecionando para outro endereço e ID (indentificadores): Visite o site da <a href="http://www.caelum.com.br">Caelum</a> e <p>Mais	informações <a href="#info">aqui</a>.</p> 

Exercícios de LINK

CSS Parte 3

1. Aplicar o conceito com exemplos e exercícios de ID e Filho (conceituando o uso de tags coringa como <div> e <span>):
- Seletor (no CSS) de ID: (#) => #cabecalho{color: white; text-align: center}, e indicar esse seletor a qualquer tag: p, div, span, desde que estejam identificadas: <span id="cabecalho"></span>
- Explanar aos alunos que o ID deve ser único em todo o documento (página), e em cascata, seus filhos.
2. Seletor Hierárquico: exemplificar com seletor (no css) e um elemento filho estilizado: 
#rodape img{
  margin-right: 30px;
  vertical-align: middle;
  width: 94px;
}
3. Float - Conceituar o uso do "float" que permite: tirar um elemento do fluxo vertical, ou elementos que ocupem toda a largura da página e fazer com que os elementos abaixo dele fula ao seu redor:

Exercícios: Seletores e Flutuação de Elementos
4. Deve-se explicar à turma o que muda no uso das tags no HTML5 e CSS3, sobre a semântica que devemos usar e sobre a compatibilidade com os navegadores.

 
HTML SEMÂNTICO E POSICIONAMENTO NO CSS

1. Conceituar o Processo de Desenvolvimento de uma tela falando sobre os levantamentos de requisitos, profissionais e ferramentas utilizadas para desenvolver um rascunho do projeto. (Recusros: Pesquisas, levantamento de requisitos com o cliente, profissionais: (Pessoas formadas na área de comunicação) e áreas responsáveis: UX (User Experience Design) e IxD (Interection Design).
2. Esboços das visões: chamados de wireframes e auxiliam no restante do design. (mostrar um exemplo de wireframe). - Mostrar aos alunos um exemplo de wireframe.
3. Com o wireframe em mãos: adicionar cores, imagens, textos. Trabalho de responsabilidade dos Designers, que usam como ferramanta: Photoshop, Fireworks, GIMP, etc.
4. Mostrar aos alunos que é à partir daí que a equipe de programadores frontend entra. Para dar vida ao projeto e fazer funcionar.
5. O Projeto Mirror Fashion - uma equipe de UX já desenvolveu a ideia que iremos praticar - Mostrar um modelo de como ficará a página.

ANALISANDO O LAYOUT
1. Levar os alunos a fazer uma análise do comportamento e disposição dos elementos na página, como por exemplo, o cabeçalho e rodapé que deverão ser padrão para as demais páginas e ensinar que a leitura dos elementos devem ser da esquerda para a direita e para baixo.

ESTRUTURA DA PÁGINA
1. Analisar que a página poderá ser dividida em três partes, sendo Cabeçalho, Conteúdo (será diferente para cada página), e rodapé.
2. Analisar a largura e limite de cada conteúdo dentro de cada um desses elementos

EXERCÍCIO INDEX
1. Adicionar os códigos de definição das áreas: 
<body>
  <header>
	<!-- Conteúdo do cabeçalho	-->
  </header>

  <div id="main">
  	<!-- Conteúdo principal	-->
  </div>

  <div id="destaques">
  	<!-- Painéis com destaques	-->
  </div>
  
  <footer>
	<!-- Conteúdo do rodapé	-->
	Estrutura da página.	
  </footer>
</body>

3. Explicar aos alunos o uso das novas tags que são parte do HTML 5 (<header> e <footer>)
4. Deixar claro o distinto papel de HTML e CSS, onde o papel do HTML é marcar o conteúdo da página, e que ele precisa ser claro e limpo; O Papel do CSS sim, é de estilizar, embelezar, dar cores e efeitos visuais à página.
5. Parte Semântica do HTML. Mostrar a importância disso na página para os usuários com deficiência visual, onde a leitura semântica HTML permite que o usuário com deficiência visual ouça a leitura da página.

ANALISANDO O HEADER
1. Verificar e analisar o conteúdo de dentro do HEADER: ícone, lista, mensagens, etc.
2. Questionar: que tipo de conteúdo usaremos? E a imagem com ícone? é um texto, ou um CSS decorativo?
3. Criar o primeiro conteúdo do Header:
	<header>
            <!--	Conteúdo	do	cabeçalho	-->
            <nav>
                <ul>
                    <li><a href="#">Sua Conta</a></li>
                    <li><a href="#">Lista de Desejos</a></li>
                    <li><a href="#">Cartão Fidelidade</a></li>
                    <li><a href="sobre.html">Sobre</a></li>
                    <li><a href="#">Ajuda</a></li>
                </ul>
            </nav>
        </header>
4. Conceituar ID e Class, onde ID deve ser único e Class pode ser usado mais de uma em um mesmo elemento.
5. Exercício do conteúdo: criando o header

CSS RESET
1. Mostrar aos alunos a importância do CSS Reset que evita que o navegador utilize uma série de estilos padrão quando não há um estilo definido pelo programador, forçando um estilo padrão que é setado sempre que carregarmos a página;
2. Fazer uso dos três arquivos: Reset (muda todos os valores possíveis para um valor padrão. Por exemplo: h1 e small têm o mesmo tamanho), Base (onde margens e dimensoes de alguns elementos são padronizados) e Font (define um tamanho para tipos de forma a tornar o visual consistente inclusive nos dispositivos móveis) - frontend do Yahoo;
3. CSS Resete do Eric Meyer - é um arquivo bem reduzido.


BLOCK VS INLINE
Falar sobre a distinção desses dois tipos de elementos:
1. Falar sobre os elementos em blocos, como <h1>, <p>, <div> etc, aqueles que ao serem inseridos podemos ver que não há um elemento à sua esquerda ou direita, pois ocupam toda a largura do documento.
2. Elementos em linha são aqueles que ocupam somente o espaço necessário para que seu próprio conteúdo seja exibido, permitindo a exibição dos próximos elementos na mesma linha, exemplo: <a>, <span>, <strong>, etc...
3. DISPLAY, o atributo que permite mudar o comportamento padrão desses dois tipos de elementos: display: block, display: inline.

Exercícios Reset e Display

POSITION: STATIC, RELATIVE E ABSOLUTE

1. Esplanar para os alunos os tipos de propriedades que permitem posicionar um elemento;
2. Explicar que os objetos não obedecem essas propriedade, pois dependem de outra propriedade: position;
3. Exemplificar que o position determina qual o modo de posicionamento de um elemento, na qual ele pode receber: POSITION: STATIC, RELATIVE E ABSOLUTE;

	Explicação para a turma:
- static => elemento com essa posição permanece com sua posição padrão, não obedecendo nenhum atributo de posicionamento;
- relative => permite atribuir obedecer as regras aplicadas de cordenadas especificadas em relação a posição original do objeto;
Exemplo:

.logotipo{
	position: relative;
	top: 20px;
	left: 50px;
}
- absolute => o mais complexo, pois exigem algumas regras que alteram seu comportamento em determinadas circustâncias. Por padrão, o elemento que recebe esse atributo usa como referência qualquer elemento que seja seu pai na estrutura HTML cujo o modo desse pai seja diferente de static (que é o padrão), e obedece as regras de coordenadas de acordo com o tamanho total desse elemento pai:
	Regra 1 - Quando o elemento não tem um pai, ele usa como referência para as suas coordenadas o limite da página do lado direito e superior (conforme indicado no atributo left, right, top ou bottom).
	Regra 2 - O mesmo acontece se definirmos a propriedade relative ao elemento pai, usando o elemento pai como base de referência para as suas coordenadas (superior e direita).
	Regra 3 - caso o elemento pai não tenha uma position definida ou static (padrão), o filho se comportará como na regra 1

EXERCÍCIO DE POSICIONAMENTO

SUPORTE HTML5 NO INTERNET EXPLORER ANTIGO

1. Mostrar aos alunos que somente há suporte para tags hmlt5 à partir do IE9.
2. Se abrirmos o site em navegadores antigos, veremos a página com o conteúdo quebrado, pois o navegador não possui suporte para as tags semânticas do html5: header, footer, nav, section, etc.
3. Entretanto, há um hack https://github.com/afarkas/html5shiv aprensentar aos alunos para que com isso possam usar as tags semânticas nos navegadores antigos:
colocar esse código dentro do HEAD:

<!--[if	lt	IE	9]>
	<script	src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

4. Em versões muitos antigas, onde 1% ainda usam essas versões de IE, versão 6 e 7, não funcionam normalmente as tags mesmo usando o hack.


MAIS HTML E CSS

1.Analisar as áres do corpo e rodapé da página.

FORMULÁRIOS

1. Explanar o uso da tag <form> que tem a função de capturar dados do usuário e submetê-los a algum serviço da Internet.
2. Filhos: <input> <button> e outros.
3. Exemplificar o fluxo de dados: passam para o <form> por meio da tag <input>, que recebe os dados digitados;
4. O atributo 'type' define a finalidade desse input. Exemplo: type="search";
5. Os dados são enviados para a tag <button> que submete as informações do formulário
<form>
	<input type="search">
	<button>Buscar</button>
</form>

POSICINAMENTO COM FLOAT E CLEAR

1. Exemplificar o clear como uma propriedade que pode ser definida com 'right', 'left', ou 'both' o comportamento dos elementos que estarão ao redor do objeto que será definido com essa propriedade. Podemos dizer que sua função é: "limpe o fluxo do documento ao meu lado", impedindo que os elementos fiquem à direita, à esquerda ou em ambos os lados, respectivamente.

Para usar Clear, o outro elemento deve estar com float especificado para qual posição irá flutuar, os elementos que preencherem o espaço do fluxo devem conter o clear e definir da seguinte forma:

left: Elemento é empurrado para baixo de elementos com float left;
right: Elemento é empurrado para baixo de elementos com float right;
both: Elemento é empurrado para baixo de elementos com float left ou float right;
none: Elemento não é empurrado para baixo de elementos com float.

TRANFORMAÇÃO DE TEXTO

1. Utilizar a propriedade text-transformation: uppercase, lowercase, capitalize, 
2. Decoração de texto: mostrar exemplos de texto decorados como: <a>, <del>

CASCATA E HERANÇA NO CSS
1. Explanar o uso de cascata e herança no CSS com exemplos de divs com class="pai", e filhos com tags h1 e h2
<div id="pai">
<h1>Sou um título</h1>
<h2>Sou um subtítulo</h2>
</div>
#pai {
	color: blue;
}

#pai {
	color: blue;
}

h1 {
	padding-left: 40px;
}

SELETORES DE ATRIBUTOS:
Exemplificar:

.busca input[type=search] {
	width: 170px;
}


INHERIT
valor atribuído a uma propriedade que queremos herdar nos filhos

Exemplificar aos alunos, uma imagem que preencha uma div conforma a definições de propriedades para essa div:

<div>
	<img src="box-model.png" alt="box model">
</div>

Sempre que definirmos o tamanho da div...
div {
	border: 2px solid;
	border-color: red;
	width: 30px;
	height: 30px;
}

Teríamos que definir o tamanho da imagem para caber na div...
img {
	width: 30px;
	height:	30px;
}

Ao atribuir Inherit nas mesmas propriedades do pai e do filho, teremos os valores do filho definido automaticamente igua ao do pai:
img {
	width: inherit;
	height: inherit;
}


EXERCÍCIO MENU DE DESTAQUE


DISPLAY INLINE-BLOCK
- Explicar aos alunos que ao fazermos alterações dimensionais em <li>s essas configurações de propriedades da box (width, height, margin) são ignoradas quando aplicamos o modo de exibição inline 
- os navegadores mais modernos permitem que usemos o momo inline-block na propriedade display, de modo que as especificações de dimensões são obedecida, e permite que os elementos sejam exibidos ao lado como lementos inline.

EXERCÍCIOS - PAINÉIS FLUTUANTES


SELETORES DE ATRIBUTOS DO CSS 4

1. À partir daqui deve-se apresentar conteúdo de CSS mais avançados, como o SELETOR DE ATRIBUTOS:
	- Valor de um atributo: input[value]{color:#CC0000} - o seletor altera todas as tags <input> que têm o atributo "value" 
	- Valor específico: input[type="text"]{border-radius: 4px} 
	- Selecionar valores condicionais, por exemplo, atributo com prefixo: div[class|="menu"]{border-radius: 4px;} - nesse caso, ele agirá em todas as tags <div> onde o atributo "div" comece com a palavra "menu" seguida de hífen e qualquer outro valor na sequência: menu-principa, menu-departamento, etc.
	- Valor por palavra específica = input[value~="problema"], que seja unicamente esse nome na classe.
 
2. Explanar o uso de expressões no CSS3 que se assemelham às expressões regulares que conhecemos.
Exemplificar:

input[name^="usuario"]{color: #CCFF00} => busca por input com valor de "name" iniciando em "usuario"

input[name$="teste"]{background-color: #CCFF00; => busca por input com valor de "name" terminandos em "teste"

input[name*="tela"]{color: #666666; => busca por input com valor do atributo "name" contendo "tela" em qualquer posição

- Mostrar que os valores de atributo tem a mesma especifidade dos seletores de classe.


RODAPÉ - SEMÂNTICA HTML 5

- Exemplificar o uso do <footer> na semântica do HTML 5
- Fazer uso do Image Replacement - substituição por imagem (serve para exibir uma imagem em algum elemento que originalmente foi feito com texto. 
	Ideia:
	- Acertar o tamanho do elemento para ficar igual ao da imagem;
	- Colocar a imagem como background do elemento;
	- Esconder o texto.

- Usar a técnica de esconder o texto cusando o 'text-ident' negativo alto, com isso fazer o texto ser renderizado "fora da tela".

ESTILIZAÇÃO E POSICIONAMENTO DO RODAPÉ

	Explicar que todo elemento que queremos manter uma largura padrão, teremos que usar a classe criada para isso: container

	1. CONTAINER INTEIRO
	2. POSICIONAMENTO

>>>>>>PREPARAR AULA ATÉ AQUI <<<<<<<<

SELETORES AVANÇADOS 

1. SELETOR DE IRMÃOS (SUBLINGS)
Utilizado para estilizar todo um parágrafo após um título.
h2 ~ p {
	font-style: italic;
}


2. SELETOR IRMÃO ADJACENTE
Utilizado para selecionar o elemento imediatamente seguinte ao título por exemplo, ou seja, o <p> irmao do <h2>

h2 + p {
	font-variant: small-caps;
}


3. SELETOR FILHO DIRETO
article > h1 {
	color: blue;
}


4. SELETOR NEGAÇÃO
Uma forma de selecionar um item em específico seria reestilizá-lo após uma aplicação de estilo padrão:
p {
	color: gray;
}
p.especial {
	color: black; /* restaura cor do especial */
}

ou com CSS3 usando a tag de estilo NEGAÇÃO:
p:not(.especial) {
	color: gray;
}

a sintaxe not recebe outros tipos de seletores, além de classes, como: ids e tags.

5. PSEUDO-CLASSES
5.1. FIRST-CHILD e LAST-CHILD
<ul>
<li>Primeiro item</li> (QUEREMOS ESSE PRIMEIRO ELEMENTO VERMELHO)
<li>Segundo item</li>
<li>Terceiro item</li>
<li>Quarto item</li> (QUEREMOS ESSE ÚLTIMO ELEMENTO AZUL)
</ul>

A solução mais comum seria:

criar uma classe para cada um dos dois elementos e aplicar a cor, mas isso requer mudança no HTML, e precisaremos mudar sempre a classe no local da alteração.

As duas classe utilizadas no CSS3 são: first-child (primeiro elemento do filho de outro) e last-child (último elemento filho):

li:first-child {
color: red;
}
li:last-child {
color: blue;
}


Obs.: O suporte a esses seletores é completo nos navegadores modernos. O first-child vem desde o IE7, Firefox 3 e Chrome 4. E (estranhamente), o last-child só a partir do IE9 mas desde o Firefox 1 e Chrome 1.

5.2. NTH-CHILD
Seletor ainda mais genérico:
	NTH-CHILD(ÍNDICE DO ELEMENTO FILHO){}

O mesmo permite usar uma expressão aritimética para valores pares ou ímpares:
/* elementos pares */
li:nth-child(2n) { color: green; }

/* elementos impares */
li:nth-child(2n+1) { color: blue; }

OBS.: O suporte existe a partir do IE9, Firefox 3.5 e Chrome 1.


PSEUDO-CLASSES DE ESTADO
Usamos para aplicar efeitos visuais que simulam ações de eventos do mouse sobre um objeto, invés de usarmos JS para esse tipo de efeito.

a:hover {
	background-color:#FF00FF;
}

/* seleciona todas as âncoras que têm o atributo "href", ou seja, links */
a:link {
background-color:#FF0000;
}
/* seleciona todos os links cujo valor de "href" é um endereço já visitado */
a:visited {
background-color:#00FF00;
}
/* seleciona o link no exato momento em que clicamos nele */
a:active {
background-color:#0000FF;
}

PSEUDO-ELEMENTOS
No exemplo abaixo queremos alterar o tamanho e estilo apenas da letra 'A'. Para isso, ingenuamente, utilizaríamos uma classe <span>a</span>. Isso custaria mais trabalho de manutenção no HTML.
<p>A Caelum tem os melhores cursos!</p>

Pseudo-elementos são elementos que não existem no documento mas que podemo ser selecionados pelo CSS:

p::first-letter {
	font-size: 200%;
}

p::first-line {
	font-style: italic;
}


Alterar somente a primeira linha dos parágrafo que não procede de outro parágrafo, mas sim procedidas por títulos, figuras e etc.

:not(p) + p::first-line {
    font-variant: small-caps;
}


NOVOS CONTEÚDOS
Imagine uma lista de links que desejamos utilizar colchetes antes e depois de cada link:

[ Link 1 ]
[ Link 2 ]
[ Link 3 ]

Podemos simplesmente digitar esses valores na tela, então perguntamos:
 - Será que esses valores serão semânticos? 
 - Queremos que os colchetes sejam indexados no Google?
 - Queremos que sejam lidos como parte de texto pelos leitores de tela

Talvez não, por ser apenas um conteúdo visual. Podemos gerar os pseudo-elementos 'after' e 'before'

a:before {
	content: '[ ';
}
a:after {
	content: ' ]';
}

Podemos também adicionar um conteúdo usando pseudo-elementos com seletores de atributos:
a[href^=http//]:after {
    content: ' (externo)';
}

BORDAS ARREDONDADAS

/* todas as bordas arredondadas com um raio de 15px */
.a {
	border-radius: 15px;
}

/* borda superior esquerda e inferior direita com 5px
borda superior direita e inferior esquerda com 20px */
.b {
	border-radius: 5px 20px;
}

/* borda superior esquerda com 5px
borda superior direita e inferior esquerda com 20px
borda inferior direita com 50px */
.c {
	border-radius: 5px 20px 50px;
}

/* borda superior esquerda com 5px
borda superior direita com 20px
borda inferior direita com 50px
borda inferior esquerda com 100px */
.d {
	border-radius: 5px 20px 50px 100px;
}


TEXT-SHADOW
1. Deslocamento da sombra e cor:
p {
	text-shadow: 10px 10px red;
}

2. Grau de Espelhamento: (blur)
p {
	text-shadow: 10px 10px 5px red;
}

3. Mais de uma sombra:
p {
	text-shadow: 10px 10px 5px red, -5px -5px 4px red;
}

BOX-SHADOW
Sintaxe identica a do Text-shadow:
	1. Sombra simples	
	box-shadow: 20px 20px black;
	
	2. Sombra com blur
	box-shadow: 20px 20px 20px black;

	3. Aumentar e diminuir sombra
	box-shadow: 20px 20px 20px 30px black;

	4. Borda interna no elemento (inset)
	box-shadow: inset 0 0 40px black;


OPACIDADE E EGBA

Desde o CSS2 podemos aplicar uma transparência em objetos usando a propriedade opacity usando valores que variam entre 0 e 1:
p {
	opacity: 0.3;
}

Compatíveis com todos o tipos de canais de cores:
/* todos equivalentes */
color: white;
color: #FFFFFF;
color: rgb(255, 255, 255);

no CSS3 o modo rgb vem com um canal a mais de cores, que é o chamado de alpha, que na prática é como a propriedade de transparência do elemento:

/* branco com 80% de opacidade */
color: rgba(255,255,255, 0.8);

No caso de texto queremos apenas o fundo dele transparente e não o texto junto:
p {
	background-color: rgba(0,0,0,0.3);
	color: white;
}


CONCEITOS:

PREFIXO:
Muitos recursos do CSS3 e HTML5 ainda são experimentais, ou pelo menos eram há alguns anos atrás. As especificações ainda estão em aberto o que indica que pode levar algum tempo para que sejam fechadas.

Alguns recursos são mais estáveis e outros mais instáveis. Alguns já estão há bastante tempo na espec e não são esperadas mudanças. Por fim, alguns ainda podem sofrer mudanças por serem bem recentes.

Alguns navegadores utilizam recursos que, na prática, facilita o uso desses novos recursos até que sejam concluídos e os navegadores implementem essas novas propriedades.

Enquanto isso, fazemos uso de um recurso chamado "prefixo" específico do fabricante na frente. Quando a especificação ficar instável, tira-se esse prefixo e usa apenas a propriedade (faz-se uso da sintaxe oficial):

Alguns prefixos de fabricantes mais famosos são:
-webkit-: navegadores Webkit (Chrome, Safari, iOS, Android)
-moz-: Firefox (Mozilla)
-ms-: Internet Explorer (Microsoft)
-o-: Opera

É preciso consultar tabelas de compatibilidade para saber qual navegador suporta qual propriedade e se é necessário usar prefixos para certas versões. Se quisermos o máximo de compatibilidade, precisamos colocar vários prefixos ao mesmo tempo:

p {
/* Chrome até versão 3, Safari até versão 4 */
-webkit-border-radius: 5px;
/* Firefox até versão 3.6 */
-moz-border-radius: 5px;
/* Todas as versões modernas dos navegadores,
incluindo IE e Opera que nunca precisaram de
prefixo pra isso */
border-radius: 5px;
}


No caso do CSS3, todas as propriedades usadas até o momento são suportadas nos navegadores mais modernos: border-radius, text-shadow, box-shadow, rgba, e podem ser usados sem uso do prefixo.


GRADIENTES
Podemos usar gradientes no CSS3 sem que precisemos fazer uso de imagens.
Vantagens:
	- Simples
	- Página mais leve
	- Se adapta a todo tipo de resolução

- Tipos: Lineares e Radiais

- Sintaxe: 

.linear {
	background: linear-gradient(white, blue);
}

.radial {
	background: radial-gradient(white, blue);
}


- Uso de gradiente com angulações diferentes e diversas paradas de cores:
.gradiente {
	background: linear-gradient(45deg, #F0F9FF 0%, #CBEBFF 47%, #A1DBFF 100%);
}


GERAÇÃO DE GRADIENTE
No exemplo abaixo os navegadores mais modernos irão ignorar a cor sólida de ler a regra gradiente:

.gradiente {
	background: #CBEBFF;
	background: linear-gradient(45deg, #F0F9FF 0%, #CBEBFF 47%, #A1DBFF 100%);
}

Podemos fazer uso de uma ferramente que permite gerar elementos gradientes em estilo visual:
https://www.colorzilla.com/gradient-editor/


PROGRESSIVE ENHANCEMENT E GRACEFUL DEGRADATION

A ideia é fazer o site funcionar em qualquer navegador sem prejudicar os navegadores mais antigos e sem deixar de usar os novos recursos nos navegadores mais modernos.

'Graceful Degratation' (degradação graciosa) - foi a primeira técnica que veio com essa ideia. O objetivo era montar o site voltado aos navegadores mais modernos e fazer com que ele degradasse "graciosamente", removendo funcionalidades não suportada.

'Progressive Enhancement - tem uma ideia parecida, mas contrária. Desenvolve funcionalidades normalmente, a acrescenta-se pequenas melhorias mesmo que só funcione nos navegadores modernos. 

o CSS3 usa esse último modo. Desenvolvemos com CSS3 e acrescentamos melhorias aos poucos.


TRANSITIONS

1. Propriedade que podemos usar para definição de estilos e efeitos:

#teste {
position: relative;
	top: 10px;
}

#teste:hover {
	top: 30px;
}

Mas veremos um efeito de deslocamento menos sutil. Podemos usar efeitos de transição:

#teste:hover {
	transition: top 2s;
}

2. Por padrão a animação é linear, mas podemos usar outros tipos:
	linear		-	velocidade constante na animação;
	ease		-	redução	gradual	na velocidade da animação;
	ease-in		- aumento gradual na velocidade da animação;
	ease-in-out  	- aumento gradual, depois redução gradual na velocidade da animação;
	cubic-bezier(x1,y1,x2,y2) - curva de velocidade para animação customizada (avançado)

3. Transition Color:

#teste{
	position:relative;
	top: 10px;
	color: white;
}

#teste:hover{
	top: 30px;
	color: red;
	transition: top 2s, color 1s ease;		
}

Podemos usar o atalho "All" para aplicar a mesma animação em todas as propriedade (que já é padrão):
	transition: all 1s ease;


ESPECIFICAÇÃO TRANSFORMS
Com esta especifiação podemos usar propriedades visuais dos elementos antes impossíveis. Por exemplo, agora podemos alterar o ângulo de um elemento, mostrar em escala maior ou menor que seu tamanho padrão ou alterar a posição do elemento sem alterar a sua estrutura.

1. Translate:
.header	{
    /*	Move	o	elemento	no	eixo	horizontal	*/
    transform:	translateX(50px);
}

#main	{
    /*	Move	o	elemento	no	eixo	vertical	*/
    transform:	translateY(-20px);
}

footer	{
    /*	Move	o	elemento	nos	dois	eixos	(X,	Y)	*/
    transform:	translate(40px,	-20px);
}

2. Rotate

.quadrado{
    width: 200px;
    height: 200px;
    background: chocolate;
    transform:	rotate(-20deg);
}


3. Scale
#novidades li	{
    /*	Alterar a escala total do elemento */
    transform:	scale(1.2);
}

#mais-vendidos li	{
    /*	Alterar	a escala vertical e horizontal do elemento */
    transform:	scale(1, 0.6);
}

4. Skew
footer	{
	/*Distorcer o elemento no eixo horizontal */
	transform: skewX(10deg);
}

#social	{
	/*Distorcer o elemento no eixo vertical	*/
	transform: skewY(10deg);
}

- É possível combinar várias transformações no mesmo elemento:
html{
	transform: rotate(-30deg) scale(0.4);
}


ESPECIFICIDADE DE SELETORES CSS

O comportamento padrão dos seletores, quando não há conflitos entre propriedades, é que as propriedades sejam acomulativas. Em caso de conflito, entre propriedades de seletores equivalentes, ou até em um mesmo seletor, é aplicada a propriedade declarada depois:

<p>Texto do parágrafo em destaque</p>
<p>Texto de um parágrafo comum</p>

1. Declaração sem conflito, propriedades declaradas acumuladas:

p {
    color: navy;
}

p {
    font-size: 16px;
}

Declaração com conflito, última propriedades declarada:
p {
    color: navy; <- continua aplicando 
    font-size: 12px; <- será anulada se declarada posteriormente por outro valor
}

p {
    font-size: 16px; <- valor que sobrescreverá, se houver algun valor antes declarado.
}


2. Seletor de Tag:
div {} - seletor genérico (toda tag div receberá os valores de atributos especificados aqui).

3. Seletor de Class:
.destaque{ } - seletor um pouco mais específico (decidimos quais elementos receberá os valores especificados aqui). O valor especificado aqui é maior que o valor de Seletor de Class.

4. Seletor de Id:
#destaque{ } - seletor bem específico (só pode ter um único elemento que receberá os valores específicados aqui). A especificidade do seletor Id é maior que o valor do Seletor de Class e Seletor de Tag.

ESPECIFICADADE
Podemos adicionar um ponto em cada posição do valor de um seletor para chegarmos ao seu valor de especificidade:

Podemos usar uma tabela para ajudar no reconhecimento desses valores:

VALORES DE ESPECIFICADE DE SELETORES
-------------------------------------------------------------------------
Seletor de ID			|  Seletor de Classe	     	|  Seletor de Tag   
Ex.: #rodape{font-size: 11pt}  	|  ex.: .conteudo{width: 960px}	|  ex.: div{color:green}
	1				      1				  1

	Seguindo os valores de especifidade da tabela acima, podemos calcular os valores de especifidade para qualquer CSS, por exemplo:

p{/*valor de especificidade: 001*/
	color: blue;
}

.destaque{/*valor de especificidade: 010 */
	color: red;
}
#cabecalho{/*valor de especificidade: 100 */
	color: green;
}

	Nos seletores combinados ou compostos, basta somar os valores em suas determinadas posições:

#rodape p{/* valor de especificidade: 101 */
	font-size: 11px;
}

#cabecalho .conteudo h1	{/* valor de especificidade 111	*/
	color: green;
}

.conteudo div p span{/* valor de especificidade: 013 */
	font-size: 13px;
}

	Quando maior a propriedade do seletor, maior é a propriedado do seu valor, dessa maneira o valor de especificidade 013 sobrescreve as propriedades conflitantes para o mesmo elemento que um seletor com o valor de especificidade 001.
	Essa é a maneira simples de descobrir qual seletor tem sua propriedade aplicadas com maior propriedade.

Nos limitaremos apenas nesses três, por hora.


WEB PARA DISPOSITIVOS MÓVEIS

SITE MOBILE OU MESMO SITE?

Fazer um site específico para dispositivos móveis ou fazer um site que se ajuste a qualquer dispositivo?

Web Única (One Web) - A melhor experiência para os usuários é ter o mesmo site Desktop normal também acessível no mundo móvel. 

CSS MEDIA TYPES

Há um tempo atrás havia uma preocupação com o layout de digerentes dispositivos, desde a época do CSS2. Para resolver esse tipo de problemas usava-se o recurso chamado de Media Type. Declarávamos as chamadas de cada arquivo de folha de estilo no head da página, como chamamos o css hoje, mas usávamos três chamadas para cada tipo ou criava tudo junto no mesmo arquivo de folha de estilo.


<link	rel="stylesheet" href="site.css" media="screen"	/>
<link	rel="stylesheet" href="print.css" media="print"	/>
<link	rel="stylesheet" href="handheld.css" media="handheld"	/>

Ou:

@media screen{
	body{
		background-color: blue;
		color:	white;
	}
}

@media print{
	body{
		background-color: white;
		color:	black;
	}
}

MEDIA TYPE SCREEN & MEDIA TYPE PRINT
Esse recurso, "media type screen", deternima a visualização normal no desktop. Era comum também fazer uso do "media type print", que permitia formatar recursos tipo textos e como seriam exibidos na impressão.

HANDHELD
Havia também o "handheld", voltado para dispositivos móveis. 
O problema era que os dispositivos na época eram simples (celulares wap e palmtops) e muito limitados. Era usado para páginas bem simples.

SCREEN
Quando começaram a surgir os novos smartphones, eles eram capazes de abrir páginas mais complexas, como o próprio desktop, por exemplo o IPhone. Por isso, o IPhone e outros celulares modernos ignoram o uso dos "handheld", e consideram, na verdade, "screen". 

A solução veio com o CSS3:

Todos os smartphones e navegadores modernos suportam uma nova forma de adaptar o CSS baseado nas propriedades dos dispositivos, as "media queries" do CSS3.

Invés de indicarmos que um determinado CSS é para um "handheld" em geral, podemos indicar que determinadas regras do CSS devem ser vinculadas a propriedades dispositivo como tamanho de tela, orientação (landscape ou protrait) e até resolução em dpi:

<link rel="stylesheet" href="base.css" media="screen">
<link rel="stylesheet" href="mobile.css" media="(max-width: 480px)">

Ou separar as regras dentro do mesmo CSS:

@media screen{
	body{
		font-size: 16px;
	}
}

@media(max-width:480px)	{
	body{
		font-size: 12px;
	}
}


o Atributo "media" agora recepe expressões mais complexas. Com isso, podemos definir o tamanho da fonte que queremos em uma determinada dimensão da tela em pixels por exemplo.

VIEWPORT - área de conteúdo dos smartphones. Área que abrange todo o conteúdo do site como no desktop.

Se tentarmos ver a página com as regras do exemplo de media screen anterior, veremos que nossa página é exibida como no desktop. Parece que as regras do "max-width" são ignoradas pelos dispositivos móveis. - Exatamento porque o Viewport considrea a área dos smartphones igual a do desktop, suportando todo o conteúdo do site assim como no desktop. 

Na verdades é que os smartphones tem telas grandes e resoluções altas, justamente para poder visualizar sites complexos feitos para desktop. A tela de um IPhone4, por exemplo, é formada por 960px por 640px. Celulares Androids já chegam a 1280px, o mesmo de um Dektop.

Ainda assim a experiência dos desktops são bem diferentes dos smartphones: 
1280px em uma tela de 4 polegadas é bem diferente de 1280px em um notebook de 13 polegadas. A resolução muda. Celulares costumam ter resolução em DPI bem maior que desktops.

DPI = (pixel por polegada)

Desktop = 1280px - dpi normal
Smartphone = 1280px - dpi superior ao desktop


DEVICE-WIDTH - define um padrão de pixels (dpi) padrão do frabricante do smartphone. 
 
Os smartphones sabem que considerar a tela com 1280px não ajudará o usuário a visualizar a página otimizadas para telas menores. Há então o conceito de "device-width" que, resumidamente, representa um número em pixels que o fabricante do aparelho considera como mais próximo da sensação que o usuário tem ao visualizar a tela.

Nos Iphones, por exemplo, o "device-width" é considerado como 320px, mesmo com a tela tendo a resolução bem mais alta.

Por padrão os IPhones e Androids costumam considerar o tamanho da tela visível, chamada de "viewport", como grande o suficiente para comportar os sites desktops normais. Por isso, no exemplo de @media, a nossa página foi exibida como se estivéssemos no desktop.

Por isso declaramos a tag: <meta name="viewport" content="width=device-width"> dentro da página index.

O que acontece quando a resolução for maior que 320px?

Nosso design volta a 940px e o scroll fica horizontal. A maioria dos smartphones tem 320px de largura, mas nem todos, e o nosso layout não se ajusta bem a esses outros. Quando giramos o aparelho a resolução passa a ser (480px no Iphone e mais de 500px em muitos Androids).

O melhor seria deixar nossas configurações entre 320px e 940px que estabelecemos para o site desktop.

Como fizemos um "layout fluido", baseado em porcentagens, os elementos se ajustam a diferentes resoluções sem esforços. É uma boa prática usar porcentagens, e sempre que possível, evitar o uso de valores absolutos em pixels.

RESPONSIVE WEB DESIGN

Ess prática aplicada, chamamos de "Web Desing Responsivo". O termo surgiu no famos artigo de Ethan Marcotte e diz exatamente o que acabamos de praticar. 

3 ELEMENTOS DE UM SITE RESPONSIVO

1. Layout fluido, usando medidas flexíveis, como porcentagens;
2. media queries para ajuste de design
3. Uso de imagens flexíveis.

A ideia do responsivo é que a página se adapte a diferentes resoluções. Embora o uso das procentagens seja uma prática antiga, foi a popularização dos "media queries" que permitiram layouts verdadeiramente adaptativos.

MOBILE-FIRST

Nosso layout até agora tem sido desenvolvido pensando primeiro no desktop e depois fizemos alguns ajustes, que por sinal, modificaram alguns propriedades que já havíamos feito. Na prática, isso não é muito interessante. 
É muito mais comum e recomendado o uso da prática inversa: "mobile-first". Isto é, começar o desenvolvimento pelo mobile e, depois, adicionar suporte a layout desktop.
Ma prática, usaremos mais media-queries, mais min-width ao invés de max-width, mais comum em códigos desktop-first.

1. Inicia-se o desenvolvimento pela área mais simples, com mais restrições, o mobile.
2. O uso da tela mais simples vai nos forçar a criar página mais simples, focada e objetiva.
3. Depois, com medias queries, readaptar o layout para desktop. 

A abordagem Dektop-first começa pelo ambiente mais livre e vai tentando cortar coisas quando chega no mobile. Na prática, é muito mais trabalhosa essa prática.

PROGRESSIVE ENHACEMENT E MOBILE-FIRST
 
Criando um form para a página compras:

Semanticamente, usaremos um componente html que nos permite adicionar uma legenda e os componentes do form em seguida <fieldset> </fieldset>que vem acompanhado do <legend></legend>

Ex.:
<form>
	<fieldset>
		<legend>Escolha	a cor</legend>
		<input	type="radio" name="cor" id="verde">
		<label	for="verde">Verde</label>
		<input	type="radio" name="cor" id="rosa">
		<label	for="rosa">Rosa</label>	
		<input	type="radio" name="cor" id="azul">
		<label	for="azul">Azul</label>
	</fieldset>
	<button	class="comprar">Comprar</button>
</form>

Desenvolver um site pensando na seguinte estrutura:

1. O Html - Sua função é estruturar o conteúdo da página de uma maneira semântica e acessível, provendo uma base de funcionalidades para a página sem relação imediata com o visual;

2. O CSS - e o visual dele são uma segunda camada, que vem em cima do HTML semântico e bem construído. 

3. Java Script  - Necessário para implementar outros recursos da página, não sendo obrigatório seu uso.

Esse tipo de pensamento é chamado de Progressive Enhacement - Construir uma base sólida, simples, portável e acessível e, depois, progressivamente, incrementar a página com recursos mais avançados tanto de estilo com CSS quanto de comportamento com JavaScript.


BOX MODEL E BOX-SIZING

Box Model padrão do W3C

Quando alteramos a propriedade de elementos dentro de uma página, precisamos pensar no comportamento desses elementos na presente um do outro.
Uma forma de entender o impacto causado pela mudança é pensar no box model.

1. Box Model - É constituído por quatro áreas retangulares: conteúdo(content), espaçamento(padding), bordas(border) e margens(margin), conforme imagem:

|------------------------------------------------|
|		    Margin 			 |
|  |---------------------------------------|	 |
|  | |--------------Border---------------| |     |
|  | |	|---------------------------|	 | | 	 |
|  | |	|	    Padding	    |	 | |	 |
|  | |	|    |-----------------|    |	 | |	 |
|  | |	|    |      Content    |    |    | |     |
|  | |	|    |-----------------|    |    | |     |
|  | |	|                           |    | |     |
|  | |  |---------------------------|	 | |	 |
|  | |-----------------------------------| |	 |
|  |---------------------------------------|     |
|						 |
|------------------------------------------------|


Essas áreas se desenvolvem de dentro para fora, na ordem abaix:

Conteúdo (content) - aquilo que será exibido;
Espaçamento (padding) - distância entre a borda e o conteúdo;
Borda  (border) - Quatro linhas que envolvem a caixa (box);
Margem (margin) - distância que separa um box de outro;

Tendo em mente o "box model", precisamos ter atenção na alteração de propriedades de um elemento visualizando o impacto em sua apresentação ao lidar com as propriedades listadas acima. 

2. Box-sizing 

Por padrão, todos os elementos têm o valor 'box-sizing: content-box' o que significa que o tamanho dele é definido pelo seu conteúdo apenas -- em outras palavras, é o tal box model padrão que vimos antes. Mas podemos trocar por 'box-sizing: border-box' que indica que o tamanho agora levará em conta até a borda - ou seja, o 'width' será a soma do 'content' com a 'border' e o 'padding'

Ou seja, o tamanho da forma é somado com o tamanho da borda, em outras palavras, a borda cresce pra dentro da forma.


Obs.: Ao desenvolver mobile-first, usamos muitas media queries do tipo 'min-width' para implementar as mudanças para o tablet/desktop.

MEDIAS QUERIES - QUERIES DE CONTEÚDO

O valor que colocamos dentro dos medias queries são chamados de "breakpoints", os pontos onde o layout será ajustado no site por causa de uma resolução diferente. 

Design responsivo questiona o seguinte:
Quais os valores padrões a se colocar nos media queries?
320px, 480px, 600px, 768px, 992px, 1200px (chamamos isso de "device-driven breakpoint") - são valores gerados a partir de tamanhos de dispositivos.   

Devemos evitar essa lista de breakpoint, essa lista tráz uma meia dúzia de dispositivos, mas não atende todos (e os 360px de um Galaxy S4?). 
Usar esses valores garante apenas que a responsividade funcionará nos dispositivos específicos, nos dispositivos "padrões".

Dar preferência aos nossos breakpoints com valores baseados em nosso conteúdo, garante que nossa página funcione em todos os dispositivos.

Na prática, podemos redimensionar a janela e anotar os valores (quebrados ou não) onde o layout quebre ou fique feio, à partir daí, fazer os próprios breakpoints.


BOOTSTRAP E FRAMEWORK CSS

FORMULÁRIO
1. Atributos do Form: 
<form action="/efetivar.html" method="POST"></form>

Atributos:
 - action: Obrigatório. Esse atributo é o endereço para onde enviaremos os valores dos campos que estiverem dentro desse formulário. Como esses valores são recebidos, depende de como é feita a aplicação do lado do servidor.

 - method: Especifica o método HTTP pelo qual essa informação será transmitida. 
	Valores:
	- POST: de maneira simplista, significa que queremos inserir as informações desse formulário, salvá-la de alguma maneira.
	- GET: é utilizado quando queremos obter alguma coisa a partir das informações que estamos transmitindo, por exemplo, um formulário de busca.
  
Compotentes do Form:
 - Label: é ligado ao <input> através do atributo "for" com o nome do input:
Ex.: 	<label for="nome">Nome:</label>
	<input type="text" name="nome" id="nome">

Dessa forma quando clicamos no label, o acampo interligado será ativado para que possamos interagir com ele.

 - Input: Tipos (type)
	- text: 
		<input	type="text" name="nome_usuario">
	- password: 
		<input	type="password" name="senha">
	- checkbox: 
		<input	id="contrato" name="contrato" type="checkbox" value="sim">
		<label	for="contrato">Aceito	os	termos	do	contrato.</label>
	- radio:
		<input	type="radio" name="idade" id="idade5" value="5">
		<label	for="idade5">Menos	de	5	anos</label>
		<input	type="radio" name="idade" id="idade10" value="10">
		<label	for="idade10">Menos	de	10	anos</label>
		<input	type="radio" name="idade" id="idade15" value="15">
		<label	for="idade15">Menos	de	15	anos</label>
		<input	type="radio" name="idade" id="idade20" value="20">
		<label	for="idade20">Menos	de	20	anos</label>
	- image:
		<input	type="image" name="botao" src="images/enviar.png" alt="Botão para enviar o formulário" width="20" height="18">
	- file:
		<input	type="file" name="anexo">
	- hidden:
		<input	type="hidden" name="codigo" value="abc012xyz789">
	- button:
		<input	type="button" name="mostra_dialogo" value="Clique aqui!">
	- submit:
		<input	type="submit" name="enviar" value="Enviar">
	- reset:
		<input	type="reset" name="reset" value="Limpar">

	- textarea: 
		<textarea name="texto"></textarea>
	- Select, Optgroup e Option:
		- Estilo menu dropdown (seleciona uma opção):
		<select	name="cidades">
			<option	value="bsb">Brasília</option>
			<option	value="rj">Rio	de	Janeiro</option>
			<option	value="sp">São	Paulo</option>
		</select>
		
		- Estilo multipla seleção:
		<select	name="cidades" multiple>
			<option	value="bsb">Brasília</option>
			<option	value="rj">Rio	de	Janeiro</option>
			<option	value="sp">São	Paulo</option>
		</select>
			
		Caso necessário, dependendo do número de opções apresentadas ao usuário, pode ser interessante agrupá-las:
		<select	name="bairro">
			<optgroup label="Brasília">
				<option	value="asan_bsb">Asa Norte</option>
				<option	value="asas_bsb">Asa Sul</option>
			</optgroup>
			
			<optgroup label="Rio de Janeiro">
				<option	value="botafogo_rj">Botafogo</option>
				<option	value="centro_rj">Centro</option>
			</optgroup>

			<optgroup label="São Paulo">
				<option	value="vlmariana_sp">Vila Mariana</option>
				<option	value="centro_sp">Centro</option>
			</optgroup>
		</select>

NOVOS COMPONENTES HTML 5
Button types:
	- email - exibe teclado ou pções de e-mail nos smartphones:
		<input	type="number" max="100" step="5">
	- number - exibe um campo com setas para encrementar ou decrementar valor do campo, e valores múltiplos:
		<input type="number" max="100" step="5">
	- url - exibe teclado com opções para e-mail (www, .com. etc)
		<input type="url" name="endereco">
	- range - exibe controle deslizante para uso de valores numéricos em escala.
		<input	type="range" name="volume">
	- date, month, week, time, datetime e datetime-local - "date picker" são feitos para coletar uma informação de data e hora:
		<input	type="date" name="validade">
	- color - exibe um espectro (color picker) para seleção de cor:
		<input	type="color" name="cor_olhos">
	- search - Exibe um campo específico para busca. O atributo "results" determina quantas últimas buscas armazenadas e lembradas. Além de exibir uma lupa dentro do campo (Chrome e Safari).
		<input	type="search" results="10">
	- tel - coleta um número de telefone, permite usar teclados com informações relevantes apenas a esse tipo de entrada:
		<input	type="tel" name="telefone">


NOVOS ATRIBUTOS HTML 5 DENTRO DE ELEMENTOS DE FORMULÁRIO

	- autofocus - indica que aquele campo deve ser iniciado com o foco quando a página for carregada. 
		<input	type="text" name="nome" autofocus>

	- placeholder - exibe um texto informativo dentro do campo caso ele esteja vazio.
		<input type="text" name="nome" placeholder="Insira seu nome">

	- autocomplete, list e datalist - permite implementar uma funcionalidade de sugestão de valores para autocompletar um campo:
		<input type="text" list="cidades" autocomplete="on">
		<datalist id="cidades">
			<option	value="Brasília">
			<option	value="Rio de Janeiro">
			<option	value="São Paulo">
		</datalist>
	Obs.: Sem o list definido, mas com o automplete ligado, o campo exibirá dados digitados em outros campos para complementá-lo.

	
ÍCONES
	Biblioteca para ícones:

	- Font Awesome
	- Iconic
	- Octicons

VALIDAÇÕES
	- required - validação fraca, do lado cliente.
	- pattern - definimos entrada de valores através de expressões.
		- <input type="text" pattern="^@\w{2,}" name="usuario_twitter">
	
	1. Estilizando campo quando o valor for inválido: usando pseudo código:
		.form-control:invalid{
			border: 1px solid #CC0000;
		}

GRID RESPONSIVO DO CSS
Para facilitar o posicionamento de objetos foi desenvolvido um método, que facilita o uso de design multi coluna, chamado de grid. Os frameworks CSS, geralmente, possuem os grids prontos para utilização, pois já vem com as classes prontas. Basta usar as classes certas.
O Bootstrap possui várias dessas classes prontas.

O grid Bootstrap trabalha com o conceito de 12 colunas, permitindo escrever o código escolhendo quantas colunas nós queremos ocupar:

| .col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 |.col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 | .col-md-1 | 
| .col-md-8                                                                                    | .col-md-4                                     |
| .col-md-4                                     | .col-md-4                                    | .col-md-4                                     |
| .col-md-6                                                             | .col-md-6                                                            |


<div class="row">
	<div class="col-md-4">
		div ocupa 4/12
	</div>
	<div class="col-md-8">
		div ocupa 8/12
	</div>
</div>

a class Row é necessária para que o layout funcione corretarmente:

- Podemos criar grids dentro de grid, sempre obedecendo a divisão de 12 colunas:

<div class="row">
	<div class="col-md-4">
		...
	</div>
	
	<div class="col-md-8">
		<div class="row">
			<div class="col-md-6">
				...
			</div>
			<div class="col-md-6">
				...
			</div>
		</div>
	</div>
</div>

- RESPONSIVIDADE DO GRID:

col-	:	Extra	small	<	576px
col-sm-	:	Small	>=	576px
col-md-	:	Medium	>=	768px
col-lg-	:	Large	>=	992px
col-xl-	:	Extra	large	>=	1200px 

Podemos aplicar mais de uma classe no mesmo elemento:

<div class="row">
	<div class="col-xs-6 col-sm-4">
		...
	</div>
	<div class="col-xs-6 col-sm-8">
		...
	</div>
</div>

DADOS CUSTOMIZADOS HTML 5

	Até o HTML 4, não havia uma forma padronizada de colocar atributos customizados. 
À partir do HTML 5, atributos começando com "data-" em qualquer tab são considerados atributos customizados e não quebram a validade do HTML. Esses atributos são bastante úteis para passar informações como para um código Java Script.

	<button	class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarToggleExternalContent">


OUTROS FRAMEWORKS CSS

	- Foundation - Da Zurb, fortemente baseado em mobile e responsivo. http://foundation.zurb.com/
	- Semantic UI - Tem nomes de classes mais simples e semânticos que os outros. http://semanticui.com/
	- Pure - Do Yahoo, outra alternativa, mais recente. http://purecss.io/


Exemplos:

<!-- Bootstrap -->
	<button	class="btn btn-primary btn-lg">Clique aqui</button>

<!-- Foundation -->
	<button	class="large button">Clique aqui</button>

<!-- Semantic UI -->
	<button	class="large ui button">Clique aqui</button>

<!-- Pure -->
	<button class="pure-button pure-button-primary pure-button-large">
		Clique	aqui
	</button>


JAVA SCRIPT E INTERATIVIDADE NA WEB

<output> - essa tag representa a saída de algum cálculo ou valor simples obtido a partir de um ou mais campos de um formulário. Ele possui um atributo for que aponta de qual elemento saiu o seu valor.

	<output	for="tamanho" name="valortamanho">42</output>

Basicamente é como se fosse uma div simples, podendo ser formatada futuramente. A grande sacada é o valor semântico da tag e o que ela representa.

Usaremos esse componente para vincular a alteração feita na barra deslizante de (tamanho) para que esse valor seja modificado conforme deslizamos o componente.

Mudar o conteúdo de uma tag conforme o usuário modifica o valor no componente, não é função do HTML, por isso, usamos o Java Script.

HISTÓRIA DO JAVA SCRIPT
- Tudo começou com a necessidade de ter que tornar as páginas de navegação na internet mais dinâmicas, ou seja, uma interação maior com o usuário com as páginas. 
- Entra a Netscape, a criadora do navegador mais popular do mundo nos anos 90, de mesmo nome, criou o LiveScript, uma linguagem simples que permitia o uso de scripts dentro da própria página.
- No mesmo instante em que Java crescia no mercado, a Netscape logo rebatizou o LiveScript como JavaScript num acordo com a Sun para alavancar as duas.
- Foi quando, a atual líder do mercado, Microsoft, adicionou ao Internet Explorer o suporte a script escritos em VBScript e criou sua própria versão de JavaScript, o JScript.

CARACTERÍSTICAS DO JS
- O JavaScript, é uma linguagem de 'scripting'
- Linguagem Scripting é uma linguagem que permite controlar uma ou mais aplicações de terceiros.
- Normalmente, elas são linguagens 'interpretadas', ou seja, precisam ser compiladas. No navegador, o código é lido e intrepretado conforme é lido pelo navegador, linha à linha, conforme o HTML.
- JavaScript possui uma grande tolerância a erros, ou seja, nem sempre o erro mostra um comportamento diferente.
- O JS é enviado, pelo navegador, junto com HTML. Para que o navegador saiba diferenciar HTML de JS, é preciso envolver o código JS dentro das tags <script></script>

CONSOLE
É um componente que acompanha grandes números de navegadores, e servem para debugar o código fonte da página, inclusive auxiliando nos códigos Java Script.


AUTOMATIC SEMICOLON INSERTION (ASI) - "INSERÇÃO AUTOMÁTICA DE PONTO E VÍRGULA"

O ponto e vírgula é fundamental e não pode ser omisso no final de cada linha em JS devido o mecanismo chamado (ASI).

SEPARANDO O ARQUIVO JS DO HTML
<script	type="text/javascript" src="js/hello.js"></script>

var mensagem = "Olá mundo";
alert('mensagem'); - exibe a mensagem para usuários.
console.log(mensagem); - imprime o conteúdo escodido no console. 

Quando o console estiver aberto, não há necessidade de usar console.log para chamada de mensagem, basta chamar a variável.

DOM - PÁGINA NO MUNDO JAVASCRIPT

Para permitir alterações na página, ao carregar HTML da página, os navegadores carregam em memória uma estrutura de dados que representam cada uma de nossas tags no JavaScript. Essa estrututura é chamada de DOM ( Document Object Model ). Essa estrutura pode ser acessada pela variável global Document.
Document é o termo usado para as nossas páginas.

document.querySelector("h1"); - Pegar uma tag
document.querySelector(".class"); - pegar o valor de uma class
document.querySelector("#id"); - pegar o valor de um ID

- querySeletor

ELEMENTO DA PÁGINA COMO VARIÁVEL

- Pegando o valor de uma tag e atribuíndo em uma variável:
var titulo = document.querySelector("h1");

- Visualizando o conteúdo da tag pela variável:
titulo.textContent;

- Alterando o conteúdo da tag:
titulo.textContent = "Novo título";


QUERYSELECTORALL

document.querySelectorAll(".card") - exibe a tag chamada e seus filhos e netos...
document.querySelectorAll(".card")[0] - exibe o filhos e netos da tag chamada, chamando os elementos desse array dentro de colchete começando do 0

ALTERAÇÕES DO DOM
Ao alterarmos os elementos da página, o navegador sincroniza as mudanças e alteram a aplicaçao em tempo real.

FUNÇÕES E OS EVENTOS DO DOM
Podemos alterar o documento todo através do JavaScript, podemos fazer alterações de um conteúdo clicando em botão ou quando e não quando carregamos a página.
O problema é que todos código colocado dentro de <script> o html lê logo que a página é carregada.

Para guardarmos um código para ser executado eventualmente, precisamos usar alguns recursos. Para isso começaremos criando uma função:

- Criando a função:
function mostraAlert(){
	alert("Funciona!");
}                                       

Ao criarmos uma função o código dentro dela fica guardado e só será executado quando chamado em algum evento de click, por exemplo, quando chamamos a função.

- Chamando a função: 
mostraAlert();

- Atribuíndo a propriedade ID do botão à variável botão
//obtendo um elemento através de um seletor de ID
var botao = document.querySelector("#botaoEnviar");

- Chamando a função pelo evento no botão:

botao.onclick = mostraAlert;


EVENTOS DO MOUSE:

oninput: quando um elemento input tem seu valor modificado
onclick: quando ocorre um click com o mouse
ondblclick: quando ocorre dois clicks com o mouse
onmousemove: quando mexe o mouse
onmousedown: quando aperta o botão do mouse
onmouseup: quando solta o botão do mouse (útil com os dois acima para gerenciar drag'n'drop)
onkeypress: quando pressionar e soltar uma tecla
onkeydown: quando pressionar uma tecla
onkeyup: quando soltar uma tecla
onblur:	quando um elemento perde foco
onfocus: quando um elemento ganha foco
onchange: quando um input, select ou textarea tem seu valor alterado
onload:	quando a página é carregada
onunload: quando a página é fechada
onsubmit: disparado antes de submeter o formulário (útil para realizar validações)

Existem uma série de Eventos mais avançados como por exemplo: drag-and-drop, e até mesmo criação de eventos customizados.

FUNÇÕES	ANÔNIMAS

Antes, com a função, seria assim:
	USANDO A FUNÇÃO EM QUALQUER PARTE DO CÓDIGO: (caso queira usar a mesma função diversas vezes em pontos diferentes do código).

	- Nesse caso indicamos a função: "mostraTamanho" que será executada no momento em que alterarmos o valor em <input type="range">.
	Não estamos executando a função "mostraTamanho()", já que não colocamos parênteses. Apenas está sendo indicado o nome da função que queremos executar: 
	
	inputTamanho.oninput = mostraTamanho;
	
	function mostraTamanho(){
		outputTamanho.value = inputTamanho.value;
	}

	USANDO A FUNÇÃO EM APENAS UMA PARTE DO CÓDIGO: (no caso de uso exclusivo e específico em apenas um uso da função).
	- Há algum outro lugar do código no qual precisamos chamar essa função? Não! Por isso damos nome à uma função, para que possamos usá-la em qualquer outra parte do código. 
	- Também é muito comum que uma função tenha apenas uma chamada no código. Nesse caso, o JS permite que criemos uma função no lugar do nome dada a ela: 
	- Nesse caso, transformamos "mostraTamanho" em uma função sem nome, uma função anônima. 

	inputTamanho.oninput = function() {
		outputTamanho.value = inputTamanho.value
	}
	
		